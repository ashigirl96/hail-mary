# Memory MCP v2 Ë®≠Ë®à‰ªïÊßòÊõ∏

## 1. Ê¶ÇË¶Å

### 1.1 „Ç≥„É≥„Çª„Éó„Éà
Memory MCP v2„ÅØ„ÄÅ**„Ç∑„É≥„Éó„É´„Åï„Å®ÂÆüÁî®ÊÄß**„ÇíÊúÄÂÑ™ÂÖà„Åó„ÅüÊ∞∏Á∂öÁöÑ„É°„É¢„É™„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇÈÅéÂ∫¶„Å™Ë§áÈõëÊÄß„ÇíÈÅø„Åë„ÄÅÊÆµÈöéÁöÑ„Å´‰æ°ÂÄ§„ÇíÊèê‰æõ„Åß„Åç„ÇãË®≠Ë®à„ÇíÊé°Áî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ

### 1.2 Ë®≠Ë®àÂéüÂâá
- **KISS (Keep It Simple, Stupid)**: ÊúÄÂ∞èÈôê„ÅÆÊ©üËÉΩ„Åã„ÇâÂßã„ÇÅ„Çã
- **YAGNI (You Aren't Gonna Need It)**: ‰ªäÂøÖË¶Å„Å™„ÅÑ„ÇÇ„ÅÆ„ÅØ‰Ωú„Çâ„Å™„ÅÑ
- **ÁñéÁµêÂêà**: ÂêÑÊ©üËÉΩ„ÅåÁã¨Á´ã„Åó„Å¶Âãï‰ΩúÂèØËÉΩ
- **ÈÄ≤ÂåñÁöÑ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: ÂÆüÈöõ„ÅÆ‰ΩøÁî®„Å´Âü∫„Å•„ÅÑ„Å¶ÊàêÈï∑

### 1.3 ‰∏ªË¶Å„Å™ÁâπÂæ¥
- üìù **„Ç∑„É≥„Éó„É´„Å™„Éá„Éº„Çø„É¢„Éá„É´**: Âçò‰∏Ä„ÉÜ„Éº„Éñ„É´ + FTS5
- üîç **È´òÈÄü„Å™ÂÖ®ÊñáÊ§úÁ¥¢**: SQLite FTS5„Å´„Çà„ÇãÊó•Êú¨Ë™ûÂØæÂøúÊ§úÁ¥¢
- üìö **„Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê**: MarkdownÂΩ¢Âºè„ÅßË®òÊÜ∂„ÇíÊï¥ÁêÜ
- üîÑ **ÂÆöÊúüÁöÑ„Å™ÊúÄÈÅ©Âåñ**: reindexÊ©üËÉΩ„Å´„Çà„ÇãÈáçË§áÊéíÈô§„Å®ÂÜçÊßãÁØâ
- üè∑Ô∏è **Ë®òÊÜ∂„ÅÆÂàÜÈ°û**: tech / project-tech / domain „ÅÆ3„Ç´„ÉÜ„Ç¥„É™
- üöÄ **ÊÆµÈöéÁöÑÂÆüË£Ö**: ÂêÑ„Éï„Çß„Éº„Ç∫„ÅßÂãï„Åè‰æ°ÂÄ§„ÇíÊèê‰æõ

## 2. „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

### 2.0 ÊäÄË°ìÈÅ∏ÂÆö„ÅÆÊ†πÊã†

#### SQLite + rusqlite „ÅÆÈÅ∏ÊäûÁêÜÁî±

**„Å™„ÅúDiesel„Åß„ÅØ„Å™„Åèrusqlite„Å™„ÅÆ„ÅãÔºü**

1. **FTS5„Å®„ÅÆÂÆåÂÖ®„Å™Áµ±Âêà**
   - Memory MCP„ÅÆ‰∏≠Ê†∏Ê©üËÉΩ„Åß„ÅÇ„ÇãÂÖ®ÊñáÊ§úÁ¥¢„Å´FTS5„ÅåÂøÖÈ†à
   - Diesel„ÅØFTS5„ÇíÁõ¥Êé•„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Å™„ÅÑÔºà`sql_query`„Åß„ÅÆÂõûÈÅøÁ≠ñ„ÅåÂøÖË¶ÅÔºâ
   - rusqlite„ÅØFTS5„Å®„Ç∑„Éº„É†„É¨„Çπ„Å´Áµ±Âêà

2. **„Ç∑„É≥„Éó„É´„Å™ÊßãÈÄ†„Å´ÈÅ©Âêà**
   - „ÉÜ„Éº„Éñ„É´„Åå1„Å§„Å†„Åë„ÅÆÂçòÁ¥î„Å™ÊßãÈÄ†
   - Ë§áÈõë„Å™„É™„É¨„Éº„Ç∑„Éß„É≥„Åå„Å™„ÅÑ
   - ORM„ÅÆ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„Åå‰∏çË¶Å

3. **ÈñãÁô∫ÈÄüÂ∫¶**
   - Phase 1Ôºà2-3Êó•Ôºâ„Åß„ÅÆËøÖÈÄü„Å™ÂÆüË£Ö„ÅåÂèØËÉΩ
   - Â≠¶ÁøíÊõ≤Á∑ö„ÅåÁ∑©„ÇÑ„Åã
   - FTS5Áµ±Âêà„Å´ËøΩÂä†‰ΩúÊ•≠„Åå‰∏çË¶Å

4. **„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ**
   - `rusqlite_migration`„ÇØ„É¨„Éº„Éà„ÅßÂçÅÂàÜ„Å™ÁÆ°ÁêÜ„ÅåÂèØËÉΩ
   - Â∞ÜÊù•Diesel„Å∏„ÅÆÁßªË°å„ÇÇÂèØËÉΩ„Å™Ë®≠Ë®à

**ÂûãÂÆâÂÖ®ÊÄß„ÅÆË£úÂÆåÁ≠ñ**:
```rust
// SQL„ÇØ„Ç®„É™„ÇíÂÆöÊï∞Âåñ„Åó„Å¶ÁÆ°ÁêÜ
const INSERT_MEMORY: &str = "INSERT INTO memories ...";
const SEARCH_FTS: &str = "SELECT * FROM memories_fts ...";

// RepositoryÂ±§„ÅßÂûãÂÆâÂÖ®„Å™„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÇíÊèê‰æõ
trait MemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()>;
    fn search(&self, query: &str) -> Result<Vec<Memory>>;
}
```

### 2.1 ÂÖ®‰ΩìÊßãÊàê

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
graph TB
    subgraph "User Interface"
        A[Claude Code<br/>MCP Client]
        B[CLI<br/>hail-mary]
        C[Generated Docs<br/>*.md files]
    end
    
    subgraph "Application Layer"
        D[MCP Server<br/>remember/recall]
        E[Document Generator<br/>markdown export]
        F[Reindexer<br/>optimization]
    end
    
    subgraph "Data Layer"
        G[(SQLite DB<br/>memory.db)]
        H[FTS5 Index]
        I[Archive<br/>old DBs]
    end
    
    A -.->|stdio| D
    B --> D
    B --> E
    B --> F
    
    D --> G
    E --> G
    F --> G
    
    G --> H
    F --> I
    E --> C
    
    A -.->|@tech.md| C
    
    classDef type1 fill:#272822,stroke:#A6E22E,stroke-width:2px;
    classDef type2 fill:#272822,stroke:#66D9EF,stroke-width:2px;
    classDef type3 fill:#272822,stroke:#F92672,stroke-width:2px;
    classDef highlighted fill:#AE81FF,stroke:#66D9EF,stroke-width:3px,color:#FFF;
    
    class A,B,C type1;
    class D,E,F type2;
    class G,H,I highlighted;
```

### 2.2 „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàË™¨Êòé

#### Application Layer
- **MCP Server**: remember/recall„ÉÑ„Éº„É´„ÇíÊèê‰æõ„Åô„ÇãMCP„Çµ„Éº„Éê„Éº
- **Document Generator**: Ë®òÊÜ∂„ÇíMarkdownÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
- **Reindexer**: ÂÆöÊúüÁöÑ„Å™ÊúÄÈÅ©Âåñ„Å®ÈáçË§áÊéíÈô§ÔºàPhase 3„ÅßÂÆüË£ÖÔºâ

#### Data Layer
- **SQLite DB**: „Åô„Åπ„Å¶„ÅÆË®òÊÜ∂„Çí‰øùÂ≠ò„Åô„ÇãÂçò‰∏Ä„Éá„Éº„Çø„Éô„Éº„Çπ
- **FTS5 Index**: È´òÈÄüÂÖ®ÊñáÊ§úÁ¥¢„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
- **Archive**: reindexÊôÇ„ÅÆÊóß„Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠ò

## 3. „Éá„Éº„Çø„Éô„Éº„ÇπË®≠Ë®à

### 3.1 ÊúÄÂ∞èÈôê„ÅÆ„Çπ„Ç≠„Éº„Éû

```sql
-- „É°„Ç§„É≥„ÉÜ„Éº„Éñ„É´Ôºà„Åì„Çå„Å†„ÅëÔºÅÔºâ
CREATE TABLE memories (
    id TEXT PRIMARY KEY,              -- UUID v4
    type TEXT NOT NULL CHECK(         -- Ë®òÊÜ∂„ÅÆ„Ç´„ÉÜ„Ç¥„É™
        type IN ('tech', 'project-tech', 'domain')
    ),
    topic TEXT NOT NULL,              -- „Çø„Ç§„Éà„É´/Ë¶ÅÁ¥ÑÔºà‰∫∫Èñì„ÅåË™≠„Åø„ÇÑ„Åô„ÅÑÔºâ
    tags TEXT,                        -- „Ç´„É≥„ÉûÂå∫Âàá„Çä„ÅÆ„Çø„Ç∞Ôºà‰æã: "rust,async,tokio"Ôºâ
    content TEXT NOT NULL,            -- Êú¨Êñá
    examples TEXT,                    -- JSONÈÖçÂàó„Åß„Ç≥„Éº„Éâ‰æã„Å™„Å©„Çí‰øùÂ≠ò
    reference_count INTEGER DEFAULT 0, -- ÂèÇÁÖß„Åï„Çå„ÅüÂõûÊï∞
    confidence REAL DEFAULT 1.0       -- ‰ø°È†ºÂ∫¶„Çπ„Ç≥„Ç¢ (0.0-1.0)
        CHECK(confidence >= 0 AND confidence <= 1),
    created_at INTEGER DEFAULT (unixepoch()), -- ‰ΩúÊàêÊó•ÊôÇ
    last_accessed INTEGER,            -- ÊúÄÁµÇ„Ç¢„ÇØ„Çª„ÇπÊó•ÊôÇ
    source TEXT,                      -- ÊÉÖÂ†±Ê∫êÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
    deleted INTEGER DEFAULT 0         -- Ë´ñÁêÜÂâäÈô§„Éï„É©„Ç∞
);

-- FTS5ÂÖ®ÊñáÊ§úÁ¥¢„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE VIRTUAL TABLE memories_fts USING fts5(
    memory_id UNINDEXED,              -- Ê§úÁ¥¢ÂØæË±°Â§ñ
    topic,                            -- Ê§úÁ¥¢ÂØæË±°
    tags,                             -- Ê§úÁ¥¢ÂØæË±°
    content,                          -- Ê§úÁ¥¢ÂØæË±°
    tokenize = 'porter unicode61'     -- Êó•Êú¨Ë™ûÂØæÂøú„Éà„Éº„ÇØ„Éä„Ç§„Ç∂„Éº
);

-- ÂøÖË¶ÅÊúÄÂ∞èÈôê„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE INDEX idx_memories_type 
    ON memories(type) 
    WHERE deleted = 0;

CREATE INDEX idx_memories_ref_count 
    ON memories(reference_count DESC) 
    WHERE deleted = 0;

CREATE INDEX idx_memories_created 
    ON memories(created_at DESC) 
    WHERE deleted = 0;

-- „Éà„É™„Ç¨„Éº: FTS5„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆËá™ÂãïÊõ¥Êñ∞
CREATE TRIGGER memories_ai AFTER INSERT ON memories
WHEN NEW.deleted = 0
BEGIN
    INSERT INTO memories_fts(memory_id, topic, tags, content)
    VALUES (NEW.id, NEW.topic, NEW.tags, NEW.content);
END;

CREATE TRIGGER memories_au AFTER UPDATE ON memories
WHEN NEW.deleted = 0 AND OLD.deleted = 0
BEGIN
    UPDATE memories_fts 
    SET topic = NEW.topic, tags = NEW.tags, content = NEW.content
    WHERE memory_id = NEW.id;
END;

CREATE TRIGGER memories_ad AFTER DELETE ON memories
BEGIN
    DELETE FROM memories_fts WHERE memory_id = OLD.id;
END;

-- Ë´ñÁêÜÂâäÈô§ÊôÇ„ÅÆFTSÂâäÈô§
CREATE TRIGGER memories_soft_delete AFTER UPDATE ON memories
WHEN NEW.deleted = 1 AND OLD.deleted = 0
BEGIN
    DELETE FROM memories_fts WHERE memory_id = NEW.id;
END;
```

### 3.2 „Éá„Éº„ÇøÂûã„ÅÆË™¨Êòé

| „Éï„Ç£„Éº„É´„Éâ | Âûã | Ë™¨Êòé | ‰æã |
|-----------|-----|------|-----|
| type | TEXT | Ë®òÊÜ∂„ÅÆÂàÜÈ°û | 'tech', 'project-tech', 'domain' |
| topic | TEXT | ‰∫∫Èñì„ÅåË™≠„Åø„ÇÑ„Åô„ÅÑ„Çø„Ç§„Éà„É´ | "Rust„ÅÆÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞" |
| tags | TEXT | Ê§úÁ¥¢Áî®„Ç≠„Éº„ÉØ„Éº„Éâ | "rust,async,tokio,futures" |
| content | TEXT | Ë©≥Á¥∞„Å™ÂÜÖÂÆπ | "Rust„Åß„ÅØ async/await „Çí‰Ωø„Å£„Å¶..." |
| examples | TEXT | JSONÈÖçÂàó„ÅÆ„Ç≥„Éº„Éâ‰æã | '["async fn main() {}", "tokio::spawn"]' |

## 4. Ê©üËÉΩ‰ªïÊßò

### 4.1 MCP Tools

#### 4.1.1 remember
```typescript
interface RememberParams {
  type: 'tech' | 'project-tech' | 'domain';
  topic: string;        // „Çø„Ç§„Éà„É´ÔºàÂøÖÈ†àÔºâ
  content: string;      // Êú¨ÊñáÔºàÂøÖÈ†àÔºâ
  tags?: string[];      // „Çø„Ç∞„É™„Çπ„Éà
  examples?: string[];  // „Ç≥„Éº„Éâ‰æã„Å™„Å©
  source?: string;      // ÊÉÖÂ†±Ê∫ê
}

interface RememberResponse {
  memory_id: string;
  action: 'created' | 'updated';
  similar_count?: number;  // È°û‰ººË®òÊÜ∂„ÅÆÊï∞ÔºàPhase 3„ÅßËøΩÂä†Ôºâ
}
```

#### 4.1.2 recall
```typescript
interface RecallParams {
  query: string;        // Ê§úÁ¥¢„ÇØ„Ç®„É™
  type?: 'tech' | 'project-tech' | 'domain';  // „Éï„Ç£„É´„Çø
  tags?: string[];      // „Çø„Ç∞„Éï„Ç£„É´„Çø
  limit?: number;       // ÁµêÊûúÊï∞‰∏äÈôêÔºà„Éá„Éï„Ç©„É´„Éà: 10Ôºâ
}

interface RecallResponse {
  memories: Memory[];
  total_count: number;
}

interface Memory {
  id: string;
  type: string;
  topic: string;
  tags: string[];
  content: string;
  examples?: string[];
  reference_count: number;
  confidence: number;
  created_at: number;
}
```

### 4.2 CLI„Ç≥„Éû„É≥„Éâ

#### 4.2.1 MCP„Çµ„Éº„Éê„ÉºËµ∑Âãï
```bash
# Memory MCP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï
$ hail-mary memory serve

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßËµ∑Âãï
$ hail-mary memory serve --daemon
```

#### 4.2.2 „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
```bash
# Ë®òÊÜ∂„ÇíMarkdown„Éï„Ç°„Ç§„É´„Å´„Ç®„ÇØ„Çπ„Éù„Éº„Éà
$ hail-mary memory document

# Âá∫Âäõ:
# - ./memory-docs/tech.md
# - ./memory-docs/project-tech.md
# - ./memory-docs/domain.md

# ÁâπÂÆö„ÅÆ„Çø„Ç§„Éó„ÅÆ„Åø
$ hail-mary memory document --type tech

# Âá∫ÂäõÂÖà„ÇíÊåáÂÆö
$ hail-mary memory document --output ./docs/
```

#### 4.2.3 ReindexÔºàPhase 3Ôºâ
```bash
# „Éá„Éº„Çø„Éô„Éº„Çπ„ÇíÊúÄÈÅ©Âåñ„ÉªÂÜçÊßãÁØâ
$ hail-mary memory reindex

# „Éâ„É©„Ç§„É©„É≥ÔºàÂ§âÊõ¥ÂÜÖÂÆπ„ÇíÁ¢∫Ë™çÔºâ
$ hail-mary memory reindex --dry-run

# Ë©≥Á¥∞„É≠„Ç∞‰ªò„Åç
$ hail-mary memory reindex --verbose
```

## 5. „Éá„Éº„Çø„Éï„É≠„Éº

### 5.1 RememberÔºàË®òÊÜ∂Ôºâ„Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[Claude: remember request] --> B{Input Validation}
    B -->|Valid| C[Generate UUID]
    B -->|Invalid| Z[Error Response]
    
    C --> D[Prepare Tags]
    D --> E[Format Examples as JSON]
    
    E --> F[Check Duplicates<br/>by topic + type]
    F -->|Exists| G[Update Existing]
    F -->|New| H[Insert New Memory]
    
    G --> I[Increment reference_count]
    I --> J[Update FTS Index]
    
    H --> K[Insert into memories]
    K --> L[Insert into FTS]
    
    J --> M[Success Response]
    L --> M
    
    style A fill:#F92672
    style M fill:#A6E22E
    style Z fill:#FF6188
```

### 5.2 RecallÔºàÊ§úÁ¥¢Ôºâ„Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[Claude: recall request] --> B[Parse Query]
    B --> C{Search Strategy}
    
    C -->|With query| D[FTS5 Search]
    C -->|No query| E[Browse by Type/Tags]
    
    D --> F[Apply Filters<br/>type, tags]
    E --> F
    
    F --> G[Order by Score<br/>+ reference_count]
    G --> H[Apply Limit]
    H --> I[Load Full Records]
    I --> J[Update last_accessed]
    J --> K[Format Response]
    K --> L[Return Results]
    
    style A fill:#F92672
    style L fill:#A6E22E
```

### 5.3 Document Generation „Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[hail-mary memory document] --> B[Query memories<br/>WHERE deleted = 0]
    
    B --> C[Group by Type]
    C --> D[tech memories]
    C --> E[project-tech memories]
    C --> F[domain memories]
    
    D --> G[Sort by confidence<br/>+ reference_count]
    E --> H[Sort by confidence<br/>+ reference_count]
    F --> I[Sort by confidence<br/>+ reference_count]
    
    G --> J[Generate tech.md]
    H --> K[Generate project-tech.md]
    I --> L[Generate domain.md]
    
    J --> M[Write to ./memory-docs/]
    K --> M
    L --> M
    
    M --> N[Success: 3 files generated]
    
    style A fill:#F92672
    style N fill:#A6E22E
```

### 5.4 Reindex „Éï„É≠„ÉºÔºàPhase 3Ôºâ

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[hail-mary memory reindex] --> B[Backup current DB]
    B --> C[Load all memories]
    
    C --> D[Generate embeddings<br/>fastembed]
    D --> E[Calculate similarities]
    
    E --> F{For each pair}
    F -->|Similarity > 0.85| G[Merge Memories]
    F -->|Similarity < 0.85| H[Keep Separate]
    
    G --> I[Combine content<br/>Sum reference_count<br/>Average confidence]
    H --> J[Keep as is]
    
    I --> K[Create new DB]
    J --> K
    
    K --> L[Remove deleted = 1]
    L --> M[Rebuild FTS index]
    M --> N[Replace old DB]
    N --> O[Archive old DB]
    
    style A fill:#F92672
    style O fill:#A6E22E
```

## 6. ÂÆüË£ÖË©≥Á¥∞

### 6.1 „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†Ôºà3Â±§„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºâ

```
hail-mary/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ mod.rs       # „Çµ„Éñ„Ç≥„Éû„É≥„Éâ„Ç®„É≥„Éà„É™
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ serve.rs     # MCP„Çµ„Éº„Éê„ÉºËµ∑Âãï
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ document.rs  # „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reindex.rs   # ÂÜçÊßãÁØâÂá¶ÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ memory/              # „Éâ„É°„Ç§„É≥„É≠„Ç∏„ÉÉ„ÇØÂ±§
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.rs        # „Éá„Éº„Çø„É¢„Éá„É´
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository.rs    # RepositoryÂ±§Ôºà„Éá„Éº„Çø„Ç¢„ÇØ„Çª„ÇπÔºâ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.rs       # ServiceÂ±§Ôºà„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÔºâ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migration.rs     # „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
‚îÇ   ‚îî‚îÄ‚îÄ mcp/                 # „Ç§„É≥„Éï„É©Â±§
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îú‚îÄ‚îÄ server.rs        # MCP„Éó„É≠„Éà„Ç≥„É´ÂÆüË£Ö
‚îÇ       ‚îî‚îÄ‚îÄ handlers.rs      # MCP„ÉÑ„Éº„É´„Éè„É≥„Éâ„É©„Éº
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ memory.db            # ÁèæÂú®„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ
‚îÇ   ‚îî‚îÄ‚îÄ archive/             # ÊóßDB„ÅÆ„Ç¢„Éº„Ç´„Ç§„Éñ
‚îÇ       ‚îî‚îÄ‚îÄ memory_20250116.db
‚îî‚îÄ‚îÄ memory-docs/             # ÁîüÊàê„Åï„Çå„Åü„Éâ„Ç≠„É•„É°„É≥„Éà
    ‚îú‚îÄ‚îÄ tech.md
    ‚îú‚îÄ‚îÄ project-tech.md
    ‚îî‚îÄ‚îÄ domain.md
```

### 6.2 ‰æùÂ≠òÈñ¢‰øÇÔºàCargo.tomlÔºâ

```toml
[dependencies]
# Phase 1: Âü∫Êú¨Ê©üËÉΩ - Updated to rmcp 0.5.0
rmcp = { version = "0.5.0", features = ["server", "macros", "transport-io"] }
rusqlite = { version = "0.31", features = ["bundled", "json"] }
rusqlite_migration = "1.0"  # „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
schemars = "1"  # For structured output schemas
uuid = { version = "1", features = ["v4"] }
anyhow = "1"
thiserror = "1"  # „Ç®„É©„ÉºÂÆöÁæ©
tracing = "0.1"  # „É≠„ÇÆ„É≥„Ç∞
tracing-subscriber = "0.3"

# Phase 2: „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
pulldown-cmark = "0.9"  # MarkdownÂá¶ÁêÜ

# Phase 3: ReindexÊ©üËÉΩÔºàÂæå„ÅßËøΩÂä†Ôºâ
# fastembed = "3"
# sqlite-vec = "0.1"
```

### 6.3 „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÂÆüË£Ö

#### 6.3.1 RepositoryÂ±§

```rust
use rusqlite::{Connection, Result, params};
use crate::memory::models::Memory;

// SQL„ÇØ„Ç®„É™„ÇíÂÆöÊï∞ÂåñÔºàÂûãÂÆâÂÖ®ÊÄß„ÅÆË£úÂÆåÔºâ
const INSERT_MEMORY: &str = r#"
    INSERT INTO memories (id, type, topic, tags, content, examples, 
                         reference_count, confidence, created_at, 
                         source, deleted)
    VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)
"#;

const SEARCH_MEMORIES_FTS: &str = r#"
    SELECT m.* FROM memories m
    JOIN memories_fts f ON m.id = f.memory_id
    WHERE f.memories_fts MATCH ?
    AND m.deleted = 0
    ORDER BY rank
    LIMIT ?
"#;

pub trait MemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()>;
    fn find_by_id(&self, id: &str) -> Result<Option<Memory>>;
    fn search(&self, query: &str, limit: usize) -> Result<Vec<Memory>>;
    fn update_reference_count(&mut self, id: &str) -> Result<()>;
}

pub struct SqliteMemoryRepository {
    conn: Connection,
}

impl MemoryRepository for SqliteMemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()> {
        self.conn.execute(
            INSERT_MEMORY,
            params![
                &memory.id,
                &memory.memory_type.to_string(),
                &memory.topic,
                &memory.tags.join(","),
                &memory.content,
                serde_json::to_string(&memory.examples).unwrap(),
                memory.reference_count,
                memory.confidence,
                memory.created_at,
                &memory.source,
                memory.deleted as i32,
            ],
        )?;
        Ok(())
    }
    
    fn search(&self, query: &str, limit: usize) -> Result<Vec<Memory>> {
        let mut stmt = self.conn.prepare(SEARCH_MEMORIES_FTS)?;
        let memory_iter = stmt.query_map(params![query, limit], |row| {
            Memory::from_row(row)
        })?;
        
        let mut memories = Vec::new();
        for memory in memory_iter {
            memories.push(memory?);
        }
        Ok(memories)
    }
    
    // ‰ªñ„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÂÆüË£Ö...
}
```

#### 6.3.2 ServiceÂ±§

```rust
use anyhow::Result;
use crate::memory::{
    models::{Memory, MemoryType},
    repository::MemoryRepository,
};

pub struct MemoryService<R: MemoryRepository> {
    repository: R,
}

impl<R: MemoryRepository> MemoryService<R> {
    pub fn new(repository: R) -> Self {
        Self { repository }
    }
    
    pub async fn remember(
        &mut self,
        memory_type: MemoryType,
        topic: String,
        content: String,
        tags: Vec<String>,
    ) -> Result<Memory> {
        // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ: ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
        if let Some(existing) = self.find_by_topic(&topic).await? {
            // Êó¢Â≠ò„ÅÆË®òÊÜ∂„ÇíÊõ¥Êñ∞
            self.repository.update_reference_count(&existing.id)?;
            return Ok(existing);
        }
        
        // Êñ∞Ë¶è‰ΩúÊàê
        let memory = Memory::new(memory_type, topic, content);
        self.repository.save(&memory)?;
        Ok(memory)
    }
    
    pub async fn recall(
        &self,
        query: &str,
        limit: usize,
    ) -> Result<Vec<Memory>> {
        // Ê§úÁ¥¢ÂÆüË°å
        let mut memories = self.repository.search(query, limit)?;
        
        // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ: ‰ø°È†ºÂ∫¶„Åß„ÇΩ„Éº„Éà
        memories.sort_by(|a, b| {
            b.confidence.partial_cmp(&a.confidence).unwrap()
        });
        
        Ok(memories)
    }
    
    async fn find_by_topic(&self, topic: &str) -> Result<Option<Memory>> {
        // „Éà„Éî„ÉÉ„ÇØ„Åß„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÂÆüË£Ö
        Ok(None) // Á∞°Áï•Âåñ
    }
}
```

#### 6.3.3 HandlerÂ±§ÔºàMCPÁµ±ÂêàÔºâ

```rust
use rmcp::{
    ErrorData as McpError, Json, ServiceExt,
    handler::server::{router::tool::ToolRouter, tool::Parameters},
    tool, tool_handler, tool_router,
    transport::stdio,
    serve_server,
};
use schemars::JsonSchema;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::memory::service::MemoryService;
use crate::memory::repository::SqliteMemoryRepository;

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RememberParams {
    pub r#type: String,
    pub topic: String,
    pub content: String,
    pub tags: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RememberResponse {
    pub memory_id: String,
    pub action: String,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RecallParams {
    pub query: String,
    pub limit: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RecallResponse {
    pub memories: Vec<Memory>,
    pub total_count: usize,
}

#[derive(Clone)]
pub struct MemoryMcpServer {
    service: Arc<Mutex<MemoryService<SqliteMemoryRepository>>>,
    tool_router: ToolRouter<Self>,
}

#[tool_handler(router = self.tool_router)]
impl rmcp::ServerHandler for MemoryMcpServer {}

#[tool_router(router = tool_router)]
impl MemoryMcpServer {
    pub fn new(db_path: impl AsRef<Path>) -> Result<Self> {
        let repository = SqliteMemoryRepository::new(db_path)?;
        let service = MemoryService::new(repository);
        
        Ok(Self {
            service: Arc::new(Mutex::new(service)),
            tool_router: Self::tool_router(),
        })
    }
    
    #[tool(name = "remember", description = "Store a memory for future recall")]
    pub async fn remember(
        &self,
        params: Parameters<RememberParams>,
    ) -> Result<Json<RememberResponse>, McpError> {
        let mut service = self.service.lock().await;
        let response = service.remember(params.0.into()).await
            .map_err(|e| McpError {
                code: -32603,
                message: e.to_string(),
                data: None,
            })?;
        Ok(Json(response.into()))
    }
    
    #[tool(name = "recall", description = "Search and retrieve stored memories")]
    pub async fn recall(
        &self,
        params: Parameters<RecallParams>,
    ) -> Result<Json<RecallResponse>, McpError> {
        let service = self.service.lock().await;
        let response = service.recall(params.0.into()).await
            .map_err(|e| McpError {
                code: -32603,
                message: e.to_string(),
                data: None,
            })?;
        Ok(Json(response.into()))
    }
}

// Server startup in main function
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let server = MemoryMcpServer::new("memory.db")?;
    serve_server(server, stdio()).await?;
    Ok()
}
```

### 6.4 „Éá„Éº„Çø„É¢„Éá„É´

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemoryType {
    Tech,         // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´‰æùÂ≠ò„Åó„Å™„ÅÑÊäÄË°ì
    ProjectTech,  // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂõ∫Êúâ„ÅÆÊäÄË°ì
    Domain,       // „Éâ„É°„Ç§„É≥Áü•Ë≠ò
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Memory {
    pub id: String,
    pub memory_type: MemoryType,
    pub topic: String,
    pub tags: Vec<String>,
    pub content: String,
    pub examples: Vec<String>,
    pub reference_count: u32,
    pub confidence: f32,
    pub created_at: i64,
    pub last_accessed: Option<i64>,
    pub source: Option<String>,
    pub deleted: bool,
}

impl Memory {
    pub fn new(
        memory_type: MemoryType,
        topic: String,
        content: String,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            memory_type,
            topic,
            tags: Vec::new(),
            content,
            examples: Vec::new(),
            reference_count: 0,
            confidence: 1.0,
            created_at: chrono::Utc::now().timestamp(),
            last_accessed: None,
            source: None,
            deleted: false,
        }
    }
}
```

## 7. ÁîüÊàê„Åï„Çå„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„Éï„Ç©„Éº„Éû„ÉÉ„Éà

### 7.1 tech.md „ÅÆ‰æã

```markdown
# Technical Knowledge

## Rust„ÅÆÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞
*Tags: rust, async, tokio*
*References: 15, Confidence: 0.95*

Rust„Åß„ÅØ `async`/`await` ÊßãÊñá„Çí‰ΩøÁî®„Åó„Å¶ÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
`tokio` „É©„É≥„Çø„Ç§„É†„ÅåÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ

### Examples:
```rust
#[tokio::main]
async fn main() {
    let result = fetch_data().await;
}

---

## React Hooks„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ
*Tags: react, hooks, frontend*
*References: 8, Confidence: 0.88*

Ôºà‰ª•‰∏ãÁ∂ö„ÅèÔºâ
```

### 7.2 project-tech.md „ÅÆ‰æã

```markdown
# Project Technical Standards

## „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Ë¶èÁ¥Ñ
*Tags: error-handling, rust, project-standard*
*References: 12, Confidence: 0.92*

„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Ç®„É©„Éº„ÅØ `anyhow::Result` „Çí‰ΩøÁî®„Åó„Å¶Âá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ
„Ç´„Çπ„Çø„É†„Ç®„É©„ÉºÂûã„ÅØ `thiserror` „Çí‰ΩøÁî®„Åó„Å¶ÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ

### Examples:
```rust
use anyhow::Result;

pub fn process_data() -> Result<()> {
    // ÂÆüË£Ö
}

---

Ôºà‰ª•‰∏ãÁ∂ö„ÅèÔºâ
```

## 8. ÂÆüË£ÖË®àÁîª

### 8.1 Phase 1: Âü∫Êú¨Ê©üËÉΩÔºà2-3Êó•Ôºâ

**ÁõÆÊ®ô**: ÊúÄÂ∞èÈôê„ÅÆMCP„Çµ„Éº„Éê„Éº„ÇíÂãï„Åã„Åô

- [ ] SQLite„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂàùÊúüÂåñ
- [ ] memories„ÉÜ„Éº„Éñ„É´„Å®FTS5„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ‰ΩúÊàê
- [ ] rusqlite_migration„Åß„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
- [ ] Repository/Service/Handler „ÅÆ3Â±§ÂÆüË£Ö
- [ ] Âü∫Êú¨ÁöÑ„Å™MCP„Çµ„Éº„Éê„ÉºÂÆüË£ÖÔºàJSON-RPC over stdioÔºâ
- [ ] remember„ÉÑ„Éº„É´„ÅÆÂÆüË£Ö
- [ ] recall„ÉÑ„Éº„É´„ÅÆÂÆüË£ÖÔºàFTS5Ê§úÁ¥¢Ôºâ
- [ ] Âü∫Êú¨ÁöÑ„Å™„ÉÜ„Çπ„Éà

**ÊàêÊûúÁâ©**: `hail-mary memory serve` „ÅßËµ∑Âãï„Åó„ÄÅClaude„Åã„ÇâË®òÊÜ∂„ÅÆ‰øùÂ≠ò„Å®Ê§úÁ¥¢„ÅåÂèØËÉΩ

### 8.2 Phase 2: „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàêÔºà1-2Êó•Ôºâ

**ÁõÆÊ®ô**: Ë®òÊÜ∂„ÇíMarkdown„ÅßÂèÇÁÖßÂèØËÉΩ„Å´„Åô„Çã

- [ ] `hail-mary memory document` „Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË£Ö
- [ ] MarkdownÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
- [ ] „Çø„Ç§„ÉóÂà•„ÅÆ„Éï„Ç°„Ç§„É´ÂàÜÂâ≤
- [ ] „Éï„Ç©„Éº„Éû„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Å®„ÇΩ„Éº„Éà
- [ ] Claude Code„Åã„Çâ `@tech.md` „ÅßÂèÇÁÖßÂèØËÉΩ„Å´

**ÊàêÊûúÁâ©**: ÁîüÊàê„Åï„Çå„ÅüMarkdown„Éï„Ç°„Ç§„É´„ÇíÁõ¥Êé•ÂèÇÁÖßÂèØËÉΩ

### 8.3 Phase 3: ReindexÊ©üËÉΩÔºà2-3Êó•Ôºâ

**ÁõÆÊ®ô**: ÂÆöÊúüÁöÑ„Å™ÊúÄÈÅ©Âåñ„Å®ÈáçË§áÊéíÈô§

- [ ] `hail-mary memory reindex` „Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË£Ö
- [ ] fastembedÁµ±ÂêàÔºà„Åì„ÅÆÊôÇÁÇπ„ÅßËøΩÂä†Ôºâ
- [ ] sqlite-vecÁµ±ÂêàÔºà„Åì„ÅÆÊôÇÁÇπ„ÅßËøΩÂä†Ôºâ
- [ ] È°û‰ººÂ∫¶Ë®àÁÆó„Å®„Éû„Éº„Ç∏„É≠„Ç∏„ÉÉ„ÇØ
- [ ] „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Å®„Ç¢„Éº„Ç´„Ç§„Éñ
- [ ] Ë´ñÁêÜÂâäÈô§„ÅÆÁâ©ÁêÜÂâäÈô§

**ÊàêÊûúÁâ©**: „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆËá™ÂãïÊúÄÈÅ©ÂåñÊ©üËÉΩ

## 9. „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõÆÊ®ô

### 9.1 „É¨„Çπ„Éù„É≥„Çπ„Çø„Ç§„É†

| Êìç‰Ωú | ÁõÆÊ®ôÊôÇÈñì | ÂÇôËÄÉ |
|------|---------|------|
| remember | < 50ms | ÂçòÁ¥î„Å™INSERT/UPDATE |
| recall (FTS) | < 100ms | 1000‰ª∂„Åß„ÅÆÊ§úÁ¥¢ |
| documentÁîüÊàê | < 1s | 1000‰ª∂„Åß„ÅÆÁîüÊàê |
| reindex | < 30s | 1000‰ª∂„Åß„ÅÆÂÜçÊßãÁØâ |

### 9.2 „Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£

- 10,000‰ª∂„ÅÆË®òÊÜ∂„Åæ„ÅßÂïèÈ°å„Å™„ÅèÂãï‰Ωú
- „Éá„Éº„Çø„Éô„Éº„Çπ„Çµ„Ç§„Ç∫: < 100MBÔºà10,000‰ª∂ÊôÇÔºâ
- „É°„É¢„É™‰ΩøÁî®Èáè: < 50MBÔºàÈÄöÂ∏∏ÈÅãÁî®ÊôÇÔºâ

## 10. „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å®„Éó„É©„Ç§„Éê„Ç∑„Éº

### 10.1 Âü∫Êú¨ÊñπÈáù

- **ÂÆåÂÖ®„É≠„Éº„Ç´„É´Âá¶ÁêÜ**: Â§ñÈÉ®API„Çí‰∏ÄÂàá‰ΩøÁî®„Åó„Å™„ÅÑ
- **„Éá„Éº„Çø‰øùË≠∑**: SQLite„Éï„Ç°„Ç§„É´„Å∏„ÅÆÈÅ©Âàá„Å™„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê
- **„Çª„É≥„Ç∑„ÉÜ„Ç£„ÉñÊÉÖÂ†±**: Ëá™ÂãïÊ§úÂá∫„Å®Ë≠¶ÂëäÔºàPhase 4„ÅßÊ§úË®éÔºâ

### 10.2 „Éá„Éº„ÇøÁÆ°ÁêÜ

- „Éá„Éº„Çø„Éô„Éº„Çπ„Éï„Ç°„Ç§„É´„ÅØ `~/.local/share/hail-mary/` „Å´‰øùÂ≠ò
- „Ç¢„Éº„Ç´„Ç§„Éñ„ÅØËá™ÂãïÁöÑ„Å´ÂúßÁ∏ÆÔºàPhase 4„ÅßÊ§úË®éÔºâ
- „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊôÇ„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ê©üËÉΩ

## 11. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

### 11.1 „Ç®„É©„ÉºÂàÜÈ°ûÔºàÊã°ÂÖÖÁâàÔºâ

```rust
#[derive(Debug, thiserror::Error)]
pub enum MemoryError {
    #[error("Database error: {0}")]
    Database(#[from] rusqlite::Error),
    
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("MCP connection error: {0}")]
    Connection(String),
    
    #[error("Database migration error: {0}")]
    Migration(String),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    // „Éâ„É°„Ç§„É≥„Ç®„É©„Éº
    #[error("Memory not found: {0}")]
    NotFound(String),
    
    #[error("Duplicate memory: {0}")]
    Duplicate(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
}
```

### 11.2 „Ç®„É©„ÉºÂá¶ÁêÜÊñπÈáù

- „Éá„Éº„Çø„Éô„Éº„Çπ„Ç®„É©„Éº: „É™„Éà„É©„Ç§„Åæ„Åü„ÅØ graceful degradation
- ÂÖ•Âäõ„Ç®„É©„Éº: ÊòéÁ¢∫„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅßÂç≥Â∫ß„Å´ËøîÂç¥
- ÈáçË§á„Ç®„É©„Éº: Êó¢Â≠ò„ÅÆË®òÊÜ∂„ÇíÊõ¥Êñ∞

## 12. „ÉÜ„Çπ„ÉàÊà¶Áï•

### 12.1 Âçò‰Ωì„ÉÜ„Çπ„Éà

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_memory_creation() {
        let memory = Memory::new(
            MemoryType::Tech,
            "Test Topic".to_string(),
            "Test Content".to_string(),
        );
        assert!(!memory.id.is_empty());
    }
    
    #[tokio::test]
    async fn test_remember_recall() {
        // FTS5Ê§úÁ¥¢„ÅÆ„ÉÜ„Çπ„Éà
    }
}
```

### 12.2 Áµ±Âêà„ÉÜ„Çπ„Éà

- MCP„Éó„É≠„Éà„Ç≥„É´Ê∫ñÊã†„ÉÜ„Çπ„Éà
- „Ç®„É≥„Éâ„ÉÑ„Éº„Ç®„É≥„Éâ„Ç∑„Éä„É™„Ç™
- „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê„ÅÆÁ¢∫Ë™ç

## 13. Â∞ÜÊù•„ÅÆÊã°ÂºµÂèØËÉΩÊÄß

### 13.1 Phase 4‰ª•Èôç„ÅÆÊ©üËÉΩÂÄôË£ú

- **Èñ¢‰øÇÊÄß„Ç∞„É©„Éï**: memoriesÈñì„ÅÆÈñ¢ÈÄ£„ÇíÁÆ°ÁêÜ
- **Ëá™Âãï„Çø„Ç∞ÁîüÊàê**: content„Åã„ÇâËá™ÂãïÁöÑ„Å´„Çø„Ç∞„ÇíÊäΩÂá∫
- **„Ç§„É≥„Éù„Éº„Éà/„Ç®„ÇØ„Çπ„Éù„Éº„Éà**: JSON/CSVÂΩ¢Âºè„Åß„ÅÆÂÖ•Âá∫Âäõ
- **Web UI**: „Éñ„É©„Ç¶„Ç∂„Åã„ÇâË®òÊÜ∂„ÇíÁÆ°ÁêÜ
- **ÂêåÊúüÊ©üËÉΩ**: Ë§áÊï∞„Éá„Éê„Ç§„ÇπÈñì„Åß„ÅÆÂêåÊúüÔºàÊöóÂè∑Âåñ‰ªò„ÅçÔºâ

### 13.2 Êã°Âºµ„Éù„Ç§„É≥„Éà

- MemoryType„ÅÆËøΩÂä†Ôºà‰æã: personal, teamÔºâ
- Ê§úÁ¥¢„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÊîπÂñÑ
- „Çà„ÇäÈ´òÂ∫¶„Å™ÈáçË§áÊ§úÂá∫
- „Éû„É´„ÉÅ„É¶„Éº„Ç∂„ÉºÂØæÂøú

## 14. „Åæ„Å®„ÇÅ

Memory MCP v2„ÅØ„ÄÅ**„Ç∑„É≥„Éó„É´„Åï„Å®ÂÆüÁî®ÊÄß**„ÇíÈáçË¶ñ„Åó„ÅüË®≠Ë®à„Å´„Çà„Çä„ÄÅ1ÈÄ±Èñì‰ª•ÂÜÖ„Å´ÂÆüÁî®ÁöÑ„Å™„É°„É¢„É™„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åß„Åç„Åæ„Åô„ÄÇ

### ‰∏ª„Å™Âà©ÁÇπ

1. **Âç≥Â∫ß„Å´‰æ°ÂÄ§„ÇíÊèê‰æõ**: Phase 1„Å†„Åë„Åß„ÇÇÂÆüÁî®ÁöÑ
2. **ÁêÜËß£„Åó„ÇÑ„Åô„ÅÑ**: Âçò‰∏Ä„ÉÜ„Éº„Éñ„É´ + FTS5„ÅÆ„Ç∑„É≥„Éó„É´ÊßãÊàê
3. **Êã°ÂºµÂèØËÉΩ**: Â∞ÜÊù•„ÅÆÊ©üËÉΩËøΩÂä†„ÅåÂÆπÊòì
4. **ÁñéÁµêÂêà**: ÂêÑÊ©üËÉΩ„ÅåÁã¨Á´ã„Åó„Å¶Âãï‰Ωú
5. **ÂÆüÁî®ÁöÑ**: „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê„ÅßÁõ¥Êé•ÂèÇÁÖßÂèØËÉΩ

### ÊàêÂäü„ÅÆÈçµ

- **ÊÆµÈöéÁöÑÂÆüË£Ö**: ÂêÑ„Éï„Çß„Éº„Ç∫„ÅßÂãï„Åè„ÇÇ„ÅÆ„ÇíÊèê‰æõ
- **„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÈáçË¶ñ**: ÂÆüÈöõ„ÅÆ‰ΩøÁî®„Å´Âü∫„Å•„ÅÑ„Å¶ÊîπÂñÑ
- **„Ç∑„É≥„Éó„É´„Åï„ÅÆÁ∂≠ÊåÅ**: Ë§áÈõë„Åï„ÇíÈÅø„Åë„ÄÅÂøÖË¶Å„Å™ÊôÇ„Å´ËøΩÂä†

„Åì„ÅÆË®≠Ë®à„Å´„Çà„Çä„ÄÅÈÅéÂ∫¶„Å™Ë§áÈõëÊÄß„ÇíÈÅø„Åë„Å™„Åå„Çâ„ÄÅÂÆüÁî®ÁöÑ„ÅßÊã°ÂºµÂèØËÉΩ„Å™„É°„É¢„É™„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüÁèæ„Åó„Åæ„Åô„ÄÇ