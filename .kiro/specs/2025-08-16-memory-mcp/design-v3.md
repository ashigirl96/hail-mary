# Memory MCP v3 Ë®≠Ë®à‰ªïÊßòÊõ∏

## 1. Ê¶ÇË¶Å

### 1.1 „Ç≥„É≥„Çª„Éó„Éà
Memory MCP v3„ÅØ„ÄÅ**„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**„Å®**SOLIDÂéüÂâá**„Å´Âü∫„Å•„ÅÑ„ÅüÊ∞∏Á∂öÁöÑ„É°„É¢„É™„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇv2„ÅÆË®≠Ë®à„ÇíÊîπËâØ„Åó„ÄÅ„Çà„ÇäÈ´ò„ÅÑ„ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£„Å®‰øùÂÆàÊÄß„ÇíÂÆüÁèæ„Åó„Åæ„Åô„ÄÇ

### 1.2 Ë®≠Ë®àÂéüÂâá
- **KISS (Keep It Simple, Stupid)**: ÊúÄÂ∞èÈôê„ÅÆÊ©üËÉΩ„Åã„ÇâÂßã„ÇÅ„Çã
- **YAGNI (You Aren't Gonna Need It)**: ‰ªäÂøÖË¶Å„Å™„ÅÑ„ÇÇ„ÅÆ„ÅØ‰Ωú„Çâ„Å™„ÅÑ
- **ÁñéÁµêÂêà**: ÂêÑÊ©üËÉΩ„ÅåÁã¨Á´ã„Åó„Å¶Âãï‰ΩúÂèØËÉΩ
- **ÈÄ≤ÂåñÁöÑ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: ÂÆüÈöõ„ÅÆ‰ΩøÁî®„Å´Âü∫„Å•„ÅÑ„Å¶ÊàêÈï∑
- **SOLIDÂéüÂâá**: Áâπ„Å´DIPÔºà‰æùÂ≠òÊÄßÈÄÜËª¢„ÅÆÂéüÂâáÔºâ„ÇíÈáçË¶ñ
- **„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: Â±§Èñì„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇíÊòéÁ¢∫Âåñ

### 1.3 ‰∏ªË¶Å„Å™ÁâπÂæ¥
- üìù **„Ç∑„É≥„Éó„É´„Å™„Éá„Éº„Çø„É¢„Éá„É´**: Âçò‰∏Ä„ÉÜ„Éº„Éñ„É´ + FTS5
- üîç **È´òÈÄü„Å™ÂÖ®ÊñáÊ§úÁ¥¢**: SQLite FTS5„Å´„Çà„ÇãÊó•Êú¨Ë™ûÂØæÂøúÊ§úÁ¥¢
- üìö **„Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê**: MarkdownÂΩ¢Âºè„ÅßË®òÊÜ∂„ÇíÊï¥ÁêÜ
- üîÑ **ÂÆöÊúüÁöÑ„Å™ÊúÄÈÅ©Âåñ**: reindexÊ©üËÉΩ„Å´„Çà„ÇãÈáçË§áÊéíÈô§„Å®ÂÜçÊßãÁØâ
- üè∑Ô∏è **Ë®òÊÜ∂„ÅÆÂàÜÈ°û**: tech / project-tech / domain „ÅÆ3„Ç´„ÉÜ„Ç¥„É™
- üöÄ **ÊÆµÈöéÁöÑÂÆüË£Ö**: ÂêÑ„Éï„Çß„Éº„Ç∫„ÅßÂãï„Åè‰æ°ÂÄ§„ÇíÊèê‰æõ
- üèóÔ∏è **„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: 4Â±§ÊßãÈÄ†„Å´„Çà„ÇãË≤¨‰ªª„ÅÆÊòéÁ¢∫„Å™ÂàÜÈõ¢
- üíâ **‰æùÂ≠òÊÄßÊ≥®ÂÖ•**: „Éà„É¨„Ç§„Éà„Å´„Çà„ÇãÊäΩË±°Âåñ„Å®„ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£Âêë‰∏ä

## 2. „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

### 2.0 ÊäÄË°ìÈÅ∏ÂÆö„ÅÆÊ†πÊã†

#### SQLite + rusqlite „ÅÆÈÅ∏ÊäûÁêÜÁî±

**„Å™„ÅúDiesel„Åß„ÅØ„Å™„Åèrusqlite„Å™„ÅÆ„ÅãÔºü**

1. **FTS5„Å®„ÅÆÂÆåÂÖ®„Å™Áµ±Âêà**
   - Memory MCP„ÅÆ‰∏≠Ê†∏Ê©üËÉΩ„Åß„ÅÇ„ÇãÂÖ®ÊñáÊ§úÁ¥¢„Å´FTS5„ÅåÂøÖÈ†à
   - Diesel„ÅØFTS5„ÇíÁõ¥Êé•„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Å™„ÅÑÔºà`sql_query`„Åß„ÅÆÂõûÈÅøÁ≠ñ„ÅåÂøÖË¶ÅÔºâ
   - rusqlite„ÅØFTS5„Å®„Ç∑„Éº„É†„É¨„Çπ„Å´Áµ±Âêà

2. **„Ç∑„É≥„Éó„É´„Å™ÊßãÈÄ†„Å´ÈÅ©Âêà**
   - „ÉÜ„Éº„Éñ„É´„Åå1„Å§„Å†„Åë„ÅÆÂçòÁ¥î„Å™ÊßãÈÄ†
   - Ë§áÈõë„Å™„É™„É¨„Éº„Ç∑„Éß„É≥„Åå„Å™„ÅÑ
   - ORM„ÅÆ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„Åå‰∏çË¶Å

3. **ÈñãÁô∫ÈÄüÂ∫¶**
   - Phase 1Ôºà2-3Êó•Ôºâ„Åß„ÅÆËøÖÈÄü„Å™ÂÆüË£Ö„ÅåÂèØËÉΩ
   - Â≠¶ÁøíÊõ≤Á∑ö„ÅåÁ∑©„ÇÑ„Åã
   - FTS5Áµ±Âêà„Å´ËøΩÂä†‰ΩúÊ•≠„Åå‰∏çË¶Å

#### RefineryÊé°Áî®„ÅÆÁêÜÁî±Ôºàv3„ÅßÊñ∞Ë¶èÊé°Áî®Ôºâ

1. **ÊàêÁÜü„Åó„Åü„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„ÉÑ„Éº„É´**
   - rusqlite_migration„Çà„ÇäË±äÂØå„Å™Ê©üËÉΩ
   - SQL„Å®Rust„ÅÆ‰∏°Êñπ„ÅÆ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Çí„Çµ„Éù„Éº„Éà
   - „Çà„ÇäÂ§ß„Åç„Å™„Ç≥„Éü„É•„Éã„ÉÜ„Ç£„Å®„Ç®„Ç≥„Ç∑„Çπ„ÉÜ„É†

2. **ÈÅãÁî®‰∏ä„ÅÆÂà©ÁÇπ**
   - „É≠„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ
   - „Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ„ÅÆÊüîËªüÊÄß
   - CI/CD„Å®„ÅÆÁµ±Âêà„ÅåÂÆπÊòì

**ÂûãÂÆâÂÖ®ÊÄß„ÅÆË£úÂÆåÁ≠ñ**:
```rust
// SQL„ÇØ„Ç®„É™„ÇíÂÆöÊï∞Âåñ„Åó„Å¶ÁÆ°ÁêÜ
const INSERT_MEMORY: &str = "INSERT INTO memories ...";
const SEARCH_FTS: &str = "SELECT * FROM memories_fts ...";

// RepositoryÂ±§„ÅßÂûãÂÆâÂÖ®„Å™„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÇíÊèê‰æõ
trait MemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()>;
    fn search(&self, query: &str) -> Result<Vec<Memory>>;
}
```

### 2.1 ÂÖ®‰ΩìÊßãÊàê

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
graph TB
    subgraph "Presentation Layer"
        A[Claude Code<br/>MCP Client]
        B[CLI Commands<br/>hail-mary]
        C[Generated Docs<br/>*.md files]
    end
    
    subgraph "Service Layer"
        D[Memory Service<br/>Business Logic]
        E[MCP Service<br/>Protocol Handler]
    end
    
    subgraph "Repository Layer"
        F[Memory Repository<br/>trait]
        G[SQLite Repository<br/>impl]
        H[InMemory Repository<br/>impl for tests]
    end
    
    subgraph "Infrastructure Layer"
        I[(SQLite DB<br/>memory.db)]
        J[FTS5 Index]
        K[Refinery<br/>Migrations]
        L[Archive<br/>old DBs]
    end
    
    A -.->|stdio| E
    B --> D
    B --> C
    
    E --> D
    D --> F
    F --> G
    F --> H
    
    G --> I
    G --> J
    K --> I
    
    I --> L
    
    classDef type1 fill:#272822,stroke:#A6E22E,stroke-width:2px;
    classDef type2 fill:#272822,stroke:#66D9EF,stroke-width:2px;
    classDef type3 fill:#272822,stroke:#F92672,stroke-width:2px;
    classDef highlighted fill:#AE81FF,stroke:#66D9EF,stroke-width:3px,color:#FFF;
    
    class A,B,C type1;
    class D,E type2;
    class F,G,H type3;
    class I,J,K,L highlighted;
```

### 2.2 „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàË™¨Êòé

#### Presentation LayerÔºà„Éó„É¨„Çº„É≥„ÉÜ„Éº„Ç∑„Éß„É≥Â±§Ôºâ
- **CLI Commands**: „É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÔºà`hail-mary memory`„Çµ„Éñ„Ç≥„Éû„É≥„ÉâÔºâ
- **MCP Client**: Claude Code„Åã„Çâ„ÅÆÊé•Á∂ö„ÇíÂèó„Åë‰ªò„Åë„Çã

#### Service LayerÔºà„Çµ„Éº„Éì„ÇπÂ±§Ôºâ
- **Memory Service**: „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË£ÖÔºàÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„ÄÅ‰ø°È†ºÂ∫¶Ë®àÁÆó„Å™„Å©Ôºâ
- **MCP Service**: MCP„Éó„É≠„Éà„Ç≥„É´„ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞Ôºàremember/recall„ÉÑ„Éº„É´Ôºâ

#### Repository LayerÔºà„É™„Éù„Ç∏„Éà„É™Â±§Ôºâ
- **Memory Repository trait**: „Éá„Éº„Çø„Ç¢„ÇØ„Çª„Çπ„ÅÆÊäΩË±°Âåñ
- **SQLite Repository**: Êú¨Áï™Áî®„ÅÆÊ∞∏Á∂öÂåñÂÆüË£Ö
- **InMemory Repository**: „ÉÜ„Çπ„ÉàÁî®„ÅÆ„Ç§„É≥„É°„É¢„É™ÂÆüË£Ö

#### Infrastructure LayerÔºà„Ç§„É≥„Éï„É©Â±§Ôºâ
- **SQLite DB**: ÂÆüÈöõ„ÅÆ„Éá„Éº„ÇøÊ∞∏Á∂öÂåñ
- **FTS5 Index**: È´òÈÄüÂÖ®ÊñáÊ§úÁ¥¢
- **Refinery**: „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
- **Archive**: Âè§„ÅÑ„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆ‰øùÁÆ°

## 3. „Éá„Éº„Çø„Éô„Éº„ÇπË®≠Ë®à

### 3.1 ÊúÄÂ∞èÈôê„ÅÆ„Çπ„Ç≠„Éº„Éû

```sql
-- „É°„Ç§„É≥„ÉÜ„Éº„Éñ„É´Ôºà„Åì„Çå„Å†„ÅëÔºÅÔºâ
CREATE TABLE memories (
    id TEXT PRIMARY KEY,              -- UUID v4
    type TEXT NOT NULL CHECK(         -- Ë®òÊÜ∂„ÅÆ„Ç´„ÉÜ„Ç¥„É™
        type IN ('tech', 'project-tech', 'domain')
    ),
    topic TEXT NOT NULL,              -- „Çø„Ç§„Éà„É´/Ë¶ÅÁ¥ÑÔºà‰∫∫Èñì„ÅåË™≠„Åø„ÇÑ„Åô„ÅÑÔºâ
    tags TEXT,                        -- „Ç´„É≥„ÉûÂå∫Âàá„Çä„ÅÆ„Çø„Ç∞Ôºà‰æã: "rust,async,tokio"Ôºâ
    content TEXT NOT NULL,            -- Êú¨Êñá
    examples TEXT,                    -- JSONÈÖçÂàó„Åß„Ç≥„Éº„Éâ‰æã„Å™„Å©„Çí‰øùÂ≠ò
    reference_count INTEGER DEFAULT 0, -- ÂèÇÁÖß„Åï„Çå„ÅüÂõûÊï∞
    confidence REAL DEFAULT 1.0       -- ‰ø°È†ºÂ∫¶„Çπ„Ç≥„Ç¢ (0.0-1.0)
        CHECK(confidence >= 0 AND confidence <= 1),
    created_at INTEGER DEFAULT (unixepoch()), -- ‰ΩúÊàêÊó•ÊôÇ
    last_accessed INTEGER,            -- ÊúÄÁµÇ„Ç¢„ÇØ„Çª„ÇπÊó•ÊôÇ
    source TEXT,                      -- ÊÉÖÂ†±Ê∫êÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
    deleted INTEGER DEFAULT 0         -- Ë´ñÁêÜÂâäÈô§„Éï„É©„Ç∞
);

-- FTS5ÂÖ®ÊñáÊ§úÁ¥¢„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE VIRTUAL TABLE memories_fts USING fts5(
    memory_id UNINDEXED,              -- Ê§úÁ¥¢ÂØæË±°Â§ñ
    topic,                            -- Ê§úÁ¥¢ÂØæË±°
    tags,                             -- Ê§úÁ¥¢ÂØæË±°
    content,                          -- Ê§úÁ¥¢ÂØæË±°
    tokenize = 'porter unicode61'     -- Êó•Êú¨Ë™ûÂØæÂøú„Éà„Éº„ÇØ„Éä„Ç§„Ç∂„Éº
);

-- ÂøÖË¶ÅÊúÄÂ∞èÈôê„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE INDEX idx_memories_type 
    ON memories(type) 
    WHERE deleted = 0;

CREATE INDEX idx_memories_ref_count 
    ON memories(reference_count DESC) 
    WHERE deleted = 0;

CREATE INDEX idx_memories_created 
    ON memories(created_at DESC) 
    WHERE deleted = 0;

-- „Éà„É™„Ç¨„Éº: FTS5„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆËá™ÂãïÊõ¥Êñ∞
CREATE TRIGGER memories_ai AFTER INSERT ON memories
WHEN NEW.deleted = 0
BEGIN
    INSERT INTO memories_fts(memory_id, topic, tags, content)
    VALUES (NEW.id, NEW.topic, NEW.tags, NEW.content);
END;

CREATE TRIGGER memories_au AFTER UPDATE ON memories
WHEN NEW.deleted = 0 AND OLD.deleted = 0
BEGIN
    UPDATE memories_fts 
    SET topic = NEW.topic, tags = NEW.tags, content = NEW.content
    WHERE memory_id = NEW.id;
END;

CREATE TRIGGER memories_ad AFTER DELETE ON memories
BEGIN
    DELETE FROM memories_fts WHERE memory_id = OLD.id;
END;

-- Ë´ñÁêÜÂâäÈô§ÊôÇ„ÅÆFTSÂâäÈô§
CREATE TRIGGER memories_soft_delete AFTER UPDATE ON memories
WHEN NEW.deleted = 1 AND OLD.deleted = 0
BEGIN
    DELETE FROM memories_fts WHERE memory_id = NEW.id;
END;
```

### 3.2 „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÊßãÈÄ†ÔºàRefinery‰ΩøÁî®Ôºâ

```
migrations/
‚îú‚îÄ‚îÄ V1__initial_schema.sql         # ÂàùÊúü„Çπ„Ç≠„Éº„Éû
‚îú‚îÄ‚îÄ V2__add_fts5_index.sql        # FTS5„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπËøΩÂä†
‚îî‚îÄ‚îÄ V3__add_triggers.sql          # „Éà„É™„Ç¨„ÉºËøΩÂä†
```

### 3.3 „Éá„Éº„ÇøÂûã„ÅÆË™¨Êòé

| „Éï„Ç£„Éº„É´„Éâ | Âûã | Ë™¨Êòé | ‰æã |
|-----------|-----|------|-----|
| type | TEXT | Ë®òÊÜ∂„ÅÆÂàÜÈ°û | 'tech', 'project-tech', 'domain' |
| topic | TEXT | ‰∫∫Èñì„ÅåË™≠„Åø„ÇÑ„Åô„ÅÑ„Çø„Ç§„Éà„É´ | "Rust„ÅÆÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞" |
| tags | TEXT | Ê§úÁ¥¢Áî®„Ç≠„Éº„ÉØ„Éº„Éâ | "rust,async,tokio,futures" |
| content | TEXT | Ë©≥Á¥∞„Å™ÂÜÖÂÆπ | "Rust„Åß„ÅØ async/await „Çí‰Ωø„Å£„Å¶..." |
| examples | TEXT | JSONÈÖçÂàó„ÅÆ„Ç≥„Éº„Éâ‰æã | '["async fn main() {}", "tokio::spawn"]' |

## 4. Ê©üËÉΩ‰ªïÊßò

### 4.1 MCP Tools

#### 4.1.1 remember
```typescript
interface RememberParams {
  type: 'tech' | 'project-tech' | 'domain';
  topic: string;        // „Çø„Ç§„Éà„É´ÔºàÂøÖÈ†àÔºâ
  content: string;      // Êú¨ÊñáÔºàÂøÖÈ†àÔºâ
  tags?: string[];      // „Çø„Ç∞„É™„Çπ„Éà
  examples?: string[];  // „Ç≥„Éº„Éâ‰æã„Å™„Å©
  source?: string;      // ÊÉÖÂ†±Ê∫ê
}

interface RememberResponse {
  memory_id: string;
  action: 'created' | 'updated';
  similar_count?: number;  // È°û‰ººË®òÊÜ∂„ÅÆÊï∞ÔºàPhase 3„ÅßËøΩÂä†Ôºâ
}
```

#### 4.1.2 recall
```typescript
interface RecallParams {
  query: string;        // Ê§úÁ¥¢„ÇØ„Ç®„É™
  type?: 'tech' | 'project-tech' | 'domain';  // „Éï„Ç£„É´„Çø
  tags?: string[];      // „Çø„Ç∞„Éï„Ç£„É´„Çø
  limit?: number;       // ÁµêÊûúÊï∞‰∏äÈôêÔºà„Éá„Éï„Ç©„É´„Éà: 10Ôºâ
}

interface RecallResponse {
  memories: Memory[];
  total_count: number;
}

interface Memory {
  id: string;
  type: string;
  topic: string;
  tags: string[];
  content: string;
  examples?: string[];
  reference_count: number;
  confidence: number;
  created_at: number;
}
```

### 4.2 CLI„Ç≥„Éû„É≥„Éâ

#### 4.2.1 MCP„Çµ„Éº„Éê„ÉºËµ∑Âãï
```bash
# Memory MCP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï
$ hail-mary memory serve

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßËµ∑Âãï
$ hail-mary memory serve --daemon
```

#### 4.2.2 „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
```bash
# Ë®òÊÜ∂„ÇíMarkdown„Éï„Ç°„Ç§„É´„Å´„Ç®„ÇØ„Çπ„Éù„Éº„Éà
$ hail-mary memory document

# Âá∫Âäõ:
# - ./memory-docs/tech.md
# - ./memory-docs/project-tech.md
# - ./memory-docs/domain.md

# ÁâπÂÆö„ÅÆ„Çø„Ç§„Éó„ÅÆ„Åø
$ hail-mary memory document --type tech

# Âá∫ÂäõÂÖà„ÇíÊåáÂÆö
$ hail-mary memory document --output ./docs/
```

#### 4.2.3 ReindexÔºàPhase 3Ôºâ
```bash
# „Éá„Éº„Çø„Éô„Éº„Çπ„ÇíÊúÄÈÅ©Âåñ„ÉªÂÜçÊßãÁØâ
$ hail-mary memory reindex

# „Éâ„É©„Ç§„É©„É≥ÔºàÂ§âÊõ¥ÂÜÖÂÆπ„ÇíÁ¢∫Ë™çÔºâ
$ hail-mary memory reindex --dry-run

# Ë©≥Á¥∞„É≠„Ç∞‰ªò„Åç
$ hail-mary memory reindex --verbose
```

## 5. „Éá„Éº„Çø„Éï„É≠„Éº

### 5.1 RememberÔºàË®òÊÜ∂Ôºâ„Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[Claude: remember request] --> B[MCP Service Layer]
    B --> C[Memory Service]
    C --> D{Input Validation}
    D -->|Valid| E[Business Logic<br/>Duplicate Check]
    D -->|Invalid| Z[Error Response]
    
    E -->|Exists| F[Update Existing]
    E -->|New| G[Create New Memory]
    
    F --> H[Repository.update]
    G --> I[Repository.save]
    
    H --> J[SQLite + FTS5]
    I --> J
    
    J --> K[Success Response]
    
    style A fill:#F92672
    style K fill:#A6E22E
    style Z fill:#FF6188
```

### 5.2 RecallÔºàÊ§úÁ¥¢Ôºâ„Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[Claude: recall request] --> B[MCP Service Layer]
    B --> C[Memory Service]
    C --> D[Parse Query]
    
    D --> E[Repository.search_fts]
    E --> F[FTS5 Query]
    
    F --> G[Apply Filters<br/>type, tags]
    G --> H[Business Logic<br/>Sort by confidence]
    H --> I[Apply Limit]
    I --> J[Update last_accessed]
    J --> K[Format Response]
    K --> L[Return Results]
    
    style A fill:#F92672
    style L fill:#A6E22E
```

### 5.3 Document Generation „Éï„É≠„Éº

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[hail-mary memory document] --> B[Document Command]
    B --> C[Memory Service]
    C --> D[Repository.find_all]
    
    D --> E[Group by Type]
    E --> F[tech memories]
    E --> G[project-tech memories]
    E --> H[domain memories]
    
    F --> I[Sort by confidence<br/>+ reference_count]
    G --> J[Sort by confidence<br/>+ reference_count]
    H --> K[Sort by confidence<br/>+ reference_count]
    
    I --> L[Generate tech.md]
    J --> M[Generate project-tech.md]
    K --> N[Generate domain.md]
    
    L --> O[Write to ./memory-docs/]
    M --> O
    N --> O
    
    O --> P[Success: 3 files generated]
    
    style A fill:#F92672
    style P fill:#A6E22E
```

### 5.4 Reindex „Éï„É≠„ÉºÔºàPhase 3Ôºâ

```mermaid
%%{init: {
  'theme': 'dark',
  'themeCSS': '
    .nodeLabel { color: #FD971F !important; }
    .edgeLabel { color: #A6E22E !important; background-color: transparent !important; }
    .cluster rect { fill: #272822 !important; stroke: #F92672 !important; stroke-width: 2px !important; rx: 5px !important; ry: 5px !important; }
    .node rect, .node circle, .node ellipse, .node polygon, .node path { fill: #272822 !important; stroke: #A6E22E !important; stroke-width: 2px !important; }
    .flowchart-link { stroke: #66D9EF !important; stroke-width: 2px !important; }
  '
}}%%
flowchart TD
    A[hail-mary memory reindex] --> B[Reindex Command]
    B --> C[Backup current DB]
    C --> D[Load all memories]
    
    D --> E[Generate embeddings<br/>fastembed]
    E --> F[Calculate similarities]
    
    F --> G{For each pair}
    G -->|Similarity > 0.85| H[Merge Memories]
    G -->|Similarity < 0.85| I[Keep Separate]
    
    H --> J[Combine content<br/>Sum reference_count<br/>Average confidence]
    I --> K[Keep as is]
    
    J --> L[Create new DB]
    K --> L
    
    L --> M[Remove deleted = 1]
    M --> N[Rebuild FTS index]
    N --> O[Replace old DB]
    O --> P[Archive old DB]
    
    style A fill:#F92672
    style P fill:#A6E22E
```

## 6. ÂÆüË£ÖË©≥Á¥∞

### 6.1 „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†Ôºà„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºâ

```
hail-mary/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ commands/              # „Éó„É¨„Çº„É≥„ÉÜ„Éº„Ç∑„Éß„É≥Â±§
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ mod.rs        # „Çµ„Éñ„Ç≥„Éû„É≥„Éâ„Ç®„É≥„Éà„É™
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ serve.rs      # MCP„Çµ„Éº„Éê„ÉºËµ∑Âãï
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ document.rs   # „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reindex.rs    # ÂÜçÊßãÁØâÂá¶ÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ services/              # „Çµ„Éº„Éì„ÇπÂ±§Ôºà„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÔºâ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.rs         # MemoryServiceÂÆüË£Ö
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory_mcp.rs     # MCPÁµ±Âêà„Çµ„Éº„Éì„Çπ
‚îÇ   ‚îú‚îÄ‚îÄ models/                # „Éâ„É°„Ç§„É≥„É¢„Éá„É´Â±§
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.rs         # MemoryÊßãÈÄ†‰Ωì„Å®„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error.rs          # „Ç®„É©„ÉºÂÆöÁæ©
‚îÇ   ‚îú‚îÄ‚îÄ repositories/          # „É™„Éù„Ç∏„Éà„É™Â±§Ôºà„Éá„Éº„Çø„Ç¢„ÇØ„Çª„ÇπÔºâ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ memory.rs         # traitÂÆöÁæ©„Å®SQLite/InMemoryÂÆüË£Ö
‚îÇ   ‚îî‚îÄ‚îÄ poc/                   # ÂÆüÈ®ìÁî®„Ç≥„Éº„Éâ
‚îú‚îÄ‚îÄ migrations/                 # Refinery„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥
‚îÇ   ‚îú‚îÄ‚îÄ V1__initial_schema.sql
‚îÇ   ‚îú‚îÄ‚îÄ V2__add_fts5_index.sql
‚îÇ   ‚îî‚îÄ‚îÄ V3__add_triggers.sql
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ memory.db              # ÁèæÂú®„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ
‚îÇ   ‚îî‚îÄ‚îÄ archive/               # ÊóßDB„ÅÆ„Ç¢„Éº„Ç´„Ç§„Éñ
‚îÇ       ‚îî‚îÄ‚îÄ memory_20250116.db
‚îî‚îÄ‚îÄ memory-docs/               # ÁîüÊàê„Åï„Çå„Åü„Éâ„Ç≠„É•„É°„É≥„Éà
    ‚îú‚îÄ‚îÄ tech.md
    ‚îú‚îÄ‚îÄ project-tech.md
    ‚îî‚îÄ‚îÄ domain.md
```

### 6.2 ‰æùÂ≠òÈñ¢‰øÇÔºàCargo.tomlÔºâ

```toml
[dependencies]
# Phase 1: Âü∫Êú¨Ê©üËÉΩ
rmcp = { version = "0.5.0", features = ["server", "macros", "transport-io"] }
rusqlite = { version = "0.31", features = ["bundled", "json"] }
refinery = { version = "0.8", features = ["rusqlite"] }  # v3„ÅßÂ§âÊõ¥
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
schemars = "1"  # For structured output schemas
uuid = { version = "1", features = ["v4"] }
anyhow = "1"
thiserror = "1"  # „Ç®„É©„ÉºÂÆöÁæ©
tracing = "0.1"  # „É≠„ÇÆ„É≥„Ç∞
tracing-subscriber = "0.3"

# Phase 2: „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê
pulldown-cmark = "0.9"  # MarkdownÂá¶ÁêÜ

# Phase 3: ReindexÊ©üËÉΩÔºàÂæå„ÅßËøΩÂä†Ôºâ
# fastembed = "3"
# sqlite-vec = "0.1"
```

### 6.3 „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÂÆüË£Ö

#### 6.3.1 RepositoryÂ±§Ôºà‰æùÂ≠òÊÄßÊ≥®ÂÖ•ÂØæÂøúÔºâ

```rust
// repositories/memory.rs
use anyhow::Result;
use crate::models::memory::Memory;

// „Éà„É¨„Ç§„Éà„Å´„Çà„ÇãÊäΩË±°Âåñ
pub trait MemoryRepository: Send + Sync {
    fn save(&mut self, memory: &Memory) -> Result<()>;
    fn find_by_id(&self, id: &str) -> Result<Option<Memory>>;
    fn find_by_topic(&self, topic: &str) -> Result<Option<Memory>>;
    fn search_fts(&self, query: &str, limit: usize) -> Result<Vec<Memory>>;
    fn update_reference_count(&mut self, id: &str) -> Result<()>;
    fn find_all(&self) -> Result<Vec<Memory>>;
}

// SQLiteÂÆüË£Ö
pub struct SqliteMemoryRepository {
    conn: rusqlite::Connection,
}

impl SqliteMemoryRepository {
    pub fn new(db_path: impl AsRef<Path>) -> Result<Self> {
        let mut conn = rusqlite::Connection::open(db_path)?;
        
        // Refinery„Åß„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÂÆüË°å
        mod embedded {
            use refinery::embed_migrations;
            embed_migrations!("./migrations");
        }
        embedded::migrations::runner().run(&mut conn)?;
        
        Ok(Self { conn })
    }
    
    // FTS5„ÇØ„Ç®„É™„Éì„É´„ÉÄ„Éº
    fn build_fts_query(&self, query: &str) -> String {
        // FTS5„ÅÆMATCHÊßãÊñá„ÇíÂÆâÂÖ®„Å´ÊßãÁØâ
        format!("SELECT m.* FROM memories m
                 JOIN memories_fts f ON m.id = f.memory_id
                 WHERE f.memories_fts MATCH ?
                 AND m.deleted = 0
                 ORDER BY rank
                 LIMIT ?")
    }
}

impl MemoryRepository for SqliteMemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()> {
        const INSERT_MEMORY: &str = r#"
            INSERT INTO memories (id, type, topic, tags, content, examples, 
                                 reference_count, confidence, created_at, 
                                 source, deleted)
            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)
        "#;
        
        self.conn.execute(
            INSERT_MEMORY,
            rusqlite::params![
                &memory.id,
                &memory.memory_type.to_string(),
                &memory.topic,
                &memory.tags.join(","),
                &memory.content,
                serde_json::to_string(&memory.examples)?,
                memory.reference_count,
                memory.confidence,
                memory.created_at,
                &memory.source,
                memory.deleted as i32,
            ],
        )?;
        Ok(())
    }
    
    fn search_fts(&self, query: &str, limit: usize) -> Result<Vec<Memory>> {
        let sql = self.build_fts_query(query);
        let mut stmt = self.conn.prepare(&sql)?;
        let memory_iter = stmt.query_map(
            rusqlite::params![query, limit],
            |row| Memory::from_row(row)
        )?;
        
        let mut memories = Vec::new();
        for memory in memory_iter {
            memories.push(memory?);
        }
        Ok(memories)
    }
    
    // ‰ªñ„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÂÆüË£Ö...
}

// „ÉÜ„Çπ„ÉàÁî®InMemoryÂÆüË£Ö
#[cfg(test)]
pub struct InMemoryRepository {
    memories: std::collections::HashMap<String, Memory>,
}

#[cfg(test)]
impl InMemoryRepository {
    pub fn new() -> Self {
        Self {
            memories: std::collections::HashMap::new(),
        }
    }
}

#[cfg(test)]
impl MemoryRepository for InMemoryRepository {
    fn save(&mut self, memory: &Memory) -> Result<()> {
        self.memories.insert(memory.id.clone(), memory.clone());
        Ok(())
    }
    
    fn find_by_id(&self, id: &str) -> Result<Option<Memory>> {
        Ok(self.memories.get(id).cloned())
    }
    
    // ‰ªñ„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÂÆüË£Ö...
}
```

#### 6.3.2 ServiceÂ±§Ôºà„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÔºâ

```rust
// services/memory.rs
use anyhow::Result;
use crate::models::memory::{Memory, MemoryType};
use crate::repositories::memory::MemoryRepository;

// „Ç∏„Çß„Éç„É™„ÉÉ„ÇØ„Å´„Çà„Çã‰æùÂ≠òÊÄßÊ≥®ÂÖ•
pub struct MemoryService<R: MemoryRepository> {
    repository: R,
}

impl<R: MemoryRepository> MemoryService<R> {
    pub fn new(repository: R) -> Self {
        Self { repository }
    }
    
    pub async fn remember(
        &mut self,
        memory_type: MemoryType,
        topic: String,
        content: String,
        tags: Vec<String>,
        examples: Vec<String>,
        source: Option<String>,
    ) -> Result<Memory> {
        // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ: ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
        if let Some(existing) = self.repository.find_by_topic(&topic)? {
            // Êó¢Â≠ò„ÅÆË®òÊÜ∂„ÇíÊõ¥Êñ∞
            self.repository.update_reference_count(&existing.id)?;
            return Ok(existing);
        }
        
        // Êñ∞Ë¶è‰ΩúÊàê
        let memory = Memory::new(memory_type, topic, content)
            .with_tags(tags)
            .with_examples(examples)
            .with_source(source);
            
        self.repository.save(&memory)?;
        Ok(memory)
    }
    
    pub async fn recall(
        &self,
        query: &str,
        limit: usize,
        type_filter: Option<MemoryType>,
        tag_filter: Vec<String>,
    ) -> Result<Vec<Memory>> {
        // FTS5Ê§úÁ¥¢ÂÆüË°å
        let mut memories = self.repository.search_fts(query, limit)?;
        
        // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ: „Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        if let Some(memory_type) = type_filter {
            memories.retain(|m| m.memory_type == memory_type);
        }
        
        if !tag_filter.is_empty() {
            memories.retain(|m| {
                tag_filter.iter().any(|tag| m.tags.contains(tag))
            });
        }
        
        // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ: ‰ø°È†ºÂ∫¶„Åß„ÇΩ„Éº„Éà
        memories.sort_by(|a, b| {
            b.confidence.partial_cmp(&a.confidence).unwrap()
                .then(b.reference_count.cmp(&a.reference_count))
        });
        
        Ok(memories)
    }
    
    pub async fn generate_documents(&self, output_dir: &Path) -> Result<()> {
        let memories = self.repository.find_all()?;
        
        // „Çø„Ç§„ÉóÂà•„Å´„Ç∞„É´„Éº„ÉóÂåñ
        let mut by_type: std::collections::HashMap<MemoryType, Vec<Memory>> = 
            std::collections::HashMap::new();
            
        for memory in memories {
            by_type.entry(memory.memory_type.clone())
                   .or_insert_with(Vec::new)
                   .push(memory);
        }
        
        // ÂêÑ„Çø„Ç§„Éó„Åî„Å®„Å´Markdown„Éï„Ç°„Ç§„É´ÁîüÊàê
        for (memory_type, mut memories) in by_type {
            // ‰ø°È†ºÂ∫¶„Å®ÂèÇÁÖßÂõûÊï∞„Åß„ÇΩ„Éº„Éà
            memories.sort_by(|a, b| {
                b.confidence.partial_cmp(&a.confidence).unwrap()
                    .then(b.reference_count.cmp(&a.reference_count))
            });
            
            let content = self.format_as_markdown(&memories);
            let filename = format!("{}.md", memory_type.to_string());
            let path = output_dir.join(filename);
            
            std::fs::write(path, content)?;
        }
        
        Ok(())
    }
    
    fn format_as_markdown(&self, memories: &[Memory]) -> String {
        // MarkdownÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
        // ...
    }
}

// „Éï„Ç°„ÇØ„Éà„É™Èñ¢Êï∞„Å´„Çà„Çã‰æùÂ≠òÊÄßÊ≥®ÂÖ•
pub fn create_memory_service(repo: impl MemoryRepository) -> MemoryService<impl MemoryRepository> {
    MemoryService::new(repo)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::repositories::memory::InMemoryRepository;
    
    #[tokio::test]
    async fn test_remember_new_memory() {
        let repo = InMemoryRepository::new();
        let mut service = MemoryService::new(repo);
        
        let memory = service.remember(
            MemoryType::Tech,
            "Test Topic".to_string(),
            "Test Content".to_string(),
            vec!["test".to_string()],
            vec![],
            None,
        ).await.unwrap();
        
        assert_eq!(memory.topic, "Test Topic");
        assert_eq!(memory.reference_count, 0);
    }
}
```

#### 6.3.3 MCP ServiceÂ±§Ôºà„Éó„É≠„Éà„Ç≥„É´Áµ±ÂêàÔºâ

```rust
// services/memory_mcp.rs
use rmcp::{
    ErrorData as McpError, Json, ServiceExt,
    handler::server::{router::tool::ToolRouter, tool::Parameters},
    tool, tool_handler, tool_router,
    transport::stdio,
    serve_server,
};
use schemars::JsonSchema;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::memory::MemoryService;
use crate::repositories::memory::MemoryRepository;

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RememberParams {
    pub r#type: String,
    pub topic: String,
    pub content: String,
    pub tags: Option<Vec<String>>,
    pub examples: Option<Vec<String>>,
    pub source: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RememberResponse {
    pub memory_id: String,
    pub action: String,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RecallParams {
    pub query: String,
    pub r#type: Option<String>,
    pub tags: Option<Vec<String>>,
    pub limit: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct RecallResponse {
    pub memories: Vec<MemoryDto>,
    pub total_count: usize,
}

#[derive(Clone)]
pub struct MemoryMcpServer<R: MemoryRepository> {
    service: Arc<Mutex<MemoryService<R>>>,
    tool_router: ToolRouter<Self>,
}

#[tool_handler(router = self.tool_router)]
impl<R: MemoryRepository + 'static> rmcp::ServerHandler for MemoryMcpServer<R> {}

#[tool_router(router = tool_router)]
impl<R: MemoryRepository + 'static> MemoryMcpServer<R> {
    pub fn new(service: MemoryService<R>) -> Self {
        Self {
            service: Arc::new(Mutex::new(service)),
            tool_router: Self::tool_router(),
        }
    }
    
    #[tool(name = "remember", description = "Store a memory for future recall")]
    pub async fn remember(
        &self,
        params: Parameters<RememberParams>,
    ) -> Result<Json<RememberResponse>, McpError> {
        let mut service = self.service.lock().await;
        
        let memory_type = params.0.r#type.parse()
            .map_err(|e| McpError {
                code: -32602,
                message: format!("Invalid type: {}", e),
                data: None,
            })?;
            
        let memory = service.remember(
            memory_type,
            params.0.topic,
            params.0.content,
            params.0.tags.unwrap_or_default(),
            params.0.examples.unwrap_or_default(),
            params.0.source,
        ).await
        .map_err(|e| McpError {
            code: -32603,
            message: e.to_string(),
            data: None,
        })?;
        
        Ok(Json(RememberResponse {
            memory_id: memory.id,
            action: "created".to_string(),
        }))
    }
    
    #[tool(name = "recall", description = "Search and retrieve stored memories")]
    pub async fn recall(
        &self,
        params: Parameters<RecallParams>,
    ) -> Result<Json<RecallResponse>, McpError> {
        let service = self.service.lock().await;
        
        let type_filter = params.0.r#type
            .map(|t| t.parse())
            .transpose()
            .map_err(|e| McpError {
                code: -32602,
                message: format!("Invalid type: {}", e),
                data: None,
            })?;
            
        let memories = service.recall(
            &params.0.query,
            params.0.limit.unwrap_or(10) as usize,
            type_filter,
            params.0.tags.unwrap_or_default(),
        ).await
        .map_err(|e| McpError {
            code: -32603,
            message: e.to_string(),
            data: None,
        })?;
        
        let total_count = memories.len();
        let memories_dto = memories.into_iter()
            .map(|m| m.into())
            .collect();
        
        Ok(Json(RecallResponse {
            memories: memories_dto,
            total_count,
        }))
    }
}
```

#### 6.3.4 CommandsÂ±§Ôºà„Éó„É¨„Çº„É≥„ÉÜ„Éº„Ç∑„Éß„É≥Ôºâ

```rust
// commands/memory/serve.rs
use anyhow::Result;
use crate::services::memory::MemoryService;
use crate::services::memory_mcp::MemoryMcpServer;
use crate::repositories::memory::SqliteMemoryRepository;
use rmcp::{serve_server, transport::stdio};

pub async fn execute(daemon: bool) -> Result<()> {
    // ‰æùÂ≠òÊÄßÊ≥®ÂÖ•„Åß„Çµ„Éº„Éì„Çπ„ÇíÊßãÁØâ
    let repository = SqliteMemoryRepository::new("data/memory.db")?;
    let service = MemoryService::new(repository);
    let mcp_server = MemoryMcpServer::new(service);
    
    if daemon {
        // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßËµ∑Âãï
        tokio::spawn(async move {
            serve_server(mcp_server, stdio()).await
        });
        println!("Memory MCP server started in background");
    } else {
        // „Éï„Ç©„Ç¢„Ç∞„É©„Ç¶„É≥„Éâ„ÅßËµ∑Âãï
        println!("Starting Memory MCP server...");
        serve_server(mcp_server, stdio()).await?;
    }
    
    Ok(())
}
```

### 6.4 „Éá„Éº„Çø„É¢„Éá„É´

```rust
// models/memory.rs
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemoryType {
    Tech,         // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´‰æùÂ≠ò„Åó„Å™„ÅÑÊäÄË°ì
    ProjectTech,  // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂõ∫Êúâ„ÅÆÊäÄË°ì
    Domain,       // „Éâ„É°„Ç§„É≥Áü•Ë≠ò
}

impl std::fmt::Display for MemoryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MemoryType::Tech => write!(f, "tech"),
            MemoryType::ProjectTech => write!(f, "project-tech"),
            MemoryType::Domain => write!(f, "domain"),
        }
    }
}

impl std::str::FromStr for MemoryType {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tech" => Ok(MemoryType::Tech),
            "project-tech" => Ok(MemoryType::ProjectTech),
            "domain" => Ok(MemoryType::Domain),
            _ => Err(format!("Invalid memory type: {}", s)),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Memory {
    pub id: String,
    pub memory_type: MemoryType,
    pub topic: String,
    pub tags: Vec<String>,
    pub content: String,
    pub examples: Vec<String>,
    pub reference_count: u32,
    pub confidence: f32,
    pub created_at: i64,
    pub last_accessed: Option<i64>,
    pub source: Option<String>,
    pub deleted: bool,
}

impl Memory {
    pub fn new(
        memory_type: MemoryType,
        topic: String,
        content: String,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            memory_type,
            topic,
            tags: Vec::new(),
            content,
            examples: Vec::new(),
            reference_count: 0,
            confidence: 1.0,
            created_at: chrono::Utc::now().timestamp(),
            last_accessed: None,
            source: None,
            deleted: false,
        }
    }
    
    // „Éì„É´„ÉÄ„Éº„Éë„Çø„Éº„É≥
    pub fn with_tags(mut self, tags: Vec<String>) -> Self {
        self.tags = tags;
        self
    }
    
    pub fn with_examples(mut self, examples: Vec<String>) -> Self {
        self.examples = examples;
        self
    }
    
    pub fn with_source(mut self, source: Option<String>) -> Self {
        self.source = source;
        self
    }
    
    // SQLite„Åã„Çâ„ÅÆÂ§âÊèõ
    pub fn from_row(row: &rusqlite::Row) -> rusqlite::Result<Self> {
        let type_str: String = row.get("type")?;
        let tags_str: String = row.get("tags")?;
        let examples_str: String = row.get("examples")?;
        
        Ok(Self {
            id: row.get("id")?,
            memory_type: type_str.parse().unwrap(),
            topic: row.get("topic")?,
            tags: if tags_str.is_empty() {
                Vec::new()
            } else {
                tags_str.split(',').map(|s| s.to_string()).collect()
            },
            content: row.get("content")?,
            examples: serde_json::from_str(&examples_str).unwrap_or_default(),
            reference_count: row.get("reference_count")?,
            confidence: row.get("confidence")?,
            created_at: row.get("created_at")?,
            last_accessed: row.get("last_accessed")?,
            source: row.get("source")?,
            deleted: row.get::<_, i32>("deleted")? != 0,
        })
    }
}
```

### 6.5 „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

```rust
// models/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MemoryError {
    #[error("Database error: {0}")]
    Database(#[from] rusqlite::Error),
    
    #[error("Migration error: {0}")]
    Migration(#[from] refinery::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("MCP protocol error: {0}")]
    Mcp(String),
    
    // „Éâ„É°„Ç§„É≥„Ç®„É©„Éº
    #[error("Memory not found: {0}")]
    NotFound(String),
    
    #[error("Duplicate memory: {0}")]
    Duplicate(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    
    #[error("Invalid memory type: {0}")]
    InvalidType(String),
}

// ResultÂûã„ÅÆ„Ç®„Ç§„É™„Ç¢„Çπ
pub type Result<T> = std::result::Result<T, MemoryError>;
```

## 7. ÁîüÊàê„Åï„Çå„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„Éï„Ç©„Éº„Éû„ÉÉ„Éà

### 7.1 tech.md „ÅÆ‰æã

```markdown
# Technical Knowledge

## Rust„ÅÆÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞
*Tags: rust, async, tokio*
*References: 15, Confidence: 0.95*

Rust„Åß„ÅØ `async`/`await` ÊßãÊñá„Çí‰ΩøÁî®„Åó„Å¶ÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ
`tokio` „É©„É≥„Çø„Ç§„É†„ÅåÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ

### Examples:
\```rust
#[tokio::main]
async fn main() {
    let result = fetch_data().await;
}
\```

---

## React Hooks„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ
*Tags: react, hooks, frontend*
*References: 8, Confidence: 0.88*

Ôºà‰ª•‰∏ãÁ∂ö„ÅèÔºâ
```

### 7.2 project-tech.md „ÅÆ‰æã

```markdown
# Project Technical Standards

## „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Ë¶èÁ¥Ñ
*Tags: error-handling, rust, project-standard*
*References: 12, Confidence: 0.92*

„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Ç®„É©„Éº„ÅØ `anyhow::Result` „Çí‰ΩøÁî®„Åó„Å¶Âá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ
„Ç´„Çπ„Çø„É†„Ç®„É©„ÉºÂûã„ÅØ `thiserror` „Çí‰ΩøÁî®„Åó„Å¶ÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ

### Examples:
\```rust
use anyhow::Result;

pub fn process_data() -> Result<()> {
    // ÂÆüË£Ö
}
\```

---

Ôºà‰ª•‰∏ãÁ∂ö„ÅèÔºâ
```

## 8. ÂÆüË£ÖË®àÁîª

### 8.0 Phase 0: „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Âü∫Áõ§Ôºà1Êó•Ôºâ

**ÁõÆÊ®ô**: „ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÂü∫Áõ§ÊßãÁØâ

- [ ] „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„ÅÆ‰ΩúÊàê
- [ ] Âü∫Êú¨ÁöÑ„Å™„Éà„É¨„Ç§„ÉàÂÆöÁæ©ÔºàMemoryRepositoryÔºâ
- [ ] „Ç®„É©„ÉºÂûãÂÆöÁæ©Ôºàthiserror‰ΩøÁî®Ôºâ
- [ ] „Éá„Éº„Çø„É¢„Éá„É´ÂÆöÁæ©ÔºàMemory, MemoryTypeÔºâ
- [ ] Cargo.tomlË®≠ÂÆö

**ÊàêÊûúÁâ©**: „Ç≥„É≥„Éë„Ç§„É´ÂèØËÉΩ„Å™Âü∫Êú¨ÊßãÈÄ†

### 8.1 Phase 1: Âü∫Êú¨Ê©üËÉΩÔºà2Êó•Ôºâ

**ÁõÆÊ®ô**: ÊúÄÂ∞èÈôê„ÅÆMCP„Çµ„Éº„Éê„Éº„ÇíÂãï„Åã„Åô

- [ ] Refinery„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö
- [ ] SQLite„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂàùÊúüÂåñ
- [ ] memories„ÉÜ„Éº„Éñ„É´„Å®FTS5„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ‰ΩúÊàê
- [ ] SqliteMemoryRepositoryÂÆüË£Ö
- [ ] InMemoryRepositoryÂÆüË£ÖÔºà„ÉÜ„Çπ„ÉàÁî®Ôºâ
- [ ] MemoryServiceÂÆüË£Ö
- [ ] MemoryMcpServerÂÆüË£Ö
- [ ] remember„ÉÑ„Éº„É´„ÅÆÂÆüË£Ö
- [ ] recall„ÉÑ„Éº„É´„ÅÆÂÆüË£ÖÔºàFTS5Ê§úÁ¥¢Ôºâ
- [ ] Âçò‰Ωì„ÉÜ„Çπ„Éà‰ΩúÊàê

**ÊàêÊûúÁâ©**: `hail-mary memory serve` „ÅßËµ∑Âãï„Åó„ÄÅClaude„Åã„ÇâË®òÊÜ∂„ÅÆ‰øùÂ≠ò„Å®Ê§úÁ¥¢„ÅåÂèØËÉΩ

### 8.2 Phase 2: „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàêÔºà1Êó•Ôºâ

**ÁõÆÊ®ô**: Ë®òÊÜ∂„ÇíMarkdown„ÅßÂèÇÁÖßÂèØËÉΩ„Å´„Åô„Çã

- [ ] `hail-mary memory document` „Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË£Ö
- [ ] MarkdownÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
- [ ] „Çø„Ç§„ÉóÂà•„ÅÆ„Éï„Ç°„Ç§„É´ÂàÜÂâ≤
- [ ] „Éï„Ç©„Éº„Éû„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Å®„ÇΩ„Éº„Éà
- [ ] Claude Code„Åã„Çâ `@tech.md` „ÅßÂèÇÁÖßÂèØËÉΩ„Å´

**ÊàêÊûúÁâ©**: ÁîüÊàê„Åï„Çå„ÅüMarkdown„Éï„Ç°„Ç§„É´„ÇíÁõ¥Êé•ÂèÇÁÖßÂèØËÉΩ

### 8.3 Phase 3: ReindexÊ©üËÉΩÔºà2Êó•Ôºâ

**ÁõÆÊ®ô**: ÂÆöÊúüÁöÑ„Å™ÊúÄÈÅ©Âåñ„Å®ÈáçË§áÊéíÈô§

- [ ] `hail-mary memory reindex` „Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË£Ö
- [ ] fastembedÁµ±Âêà
- [ ] sqlite-vecÁµ±Âêà
- [ ] È°û‰ººÂ∫¶Ë®àÁÆó„Å®„Éû„Éº„Ç∏„É≠„Ç∏„ÉÉ„ÇØ
- [ ] „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Å®„Ç¢„Éº„Ç´„Ç§„Éñ
- [ ] Ë´ñÁêÜÂâäÈô§„ÅÆÁâ©ÁêÜÂâäÈô§

**ÊàêÊûúÁâ©**: „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆËá™ÂãïÊúÄÈÅ©ÂåñÊ©üËÉΩ

## 9. „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõÆÊ®ô

### 9.1 „É¨„Çπ„Éù„É≥„Çπ„Çø„Ç§„É†

| Êìç‰Ωú | ÁõÆÊ®ôÊôÇÈñì | ÂÇôËÄÉ |
|------|---------|---------|
| remember | < 50ms | ÂçòÁ¥î„Å™INSERT/UPDATE |
| recall (FTS) | < 100ms | 1000‰ª∂„Åß„ÅÆÊ§úÁ¥¢ |
| documentÁîüÊàê | < 1s | 1000‰ª∂„Åß„ÅÆÁîüÊàê |
| reindex | < 30s | 1000‰ª∂„Åß„ÅÆÂÜçÊßãÁØâ |

### 9.2 „Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£

- 10,000‰ª∂„ÅÆË®òÊÜ∂„Åæ„ÅßÂïèÈ°å„Å™„ÅèÂãï‰Ωú
- „Éá„Éº„Çø„Éô„Éº„Çπ„Çµ„Ç§„Ç∫: < 100MBÔºà10,000‰ª∂ÊôÇÔºâ
- „É°„É¢„É™‰ΩøÁî®Èáè: < 50MBÔºàÈÄöÂ∏∏ÈÅãÁî®ÊôÇÔºâ

## 10. „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å®„Éó„É©„Ç§„Éê„Ç∑„Éº

### 10.1 Âü∫Êú¨ÊñπÈáù

- **ÂÆåÂÖ®„É≠„Éº„Ç´„É´Âá¶ÁêÜ**: Â§ñÈÉ®API„Çí‰∏ÄÂàá‰ΩøÁî®„Åó„Å™„ÅÑ
- **„Éá„Éº„Çø‰øùË≠∑**: SQLite„Éï„Ç°„Ç§„É´„Å∏„ÅÆÈÅ©Âàá„Å™„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê
- **„Çª„É≥„Ç∑„ÉÜ„Ç£„ÉñÊÉÖÂ†±**: Ëá™ÂãïÊ§úÂá∫„Å®Ë≠¶ÂëäÔºàPhase 4„ÅßÊ§úË®éÔºâ

### 10.2 „Éá„Éº„ÇøÁÆ°ÁêÜ

- „Éá„Éº„Çø„Éô„Éº„Çπ„Éï„Ç°„Ç§„É´„ÅØ `~/.local/share/hail-mary/` „Å´‰øùÂ≠ò
- „Ç¢„Éº„Ç´„Ç§„Éñ„ÅØËá™ÂãïÁöÑ„Å´ÂúßÁ∏ÆÔºàPhase 4„ÅßÊ§úË®éÔºâ
- „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊôÇ„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ê©üËÉΩ

## 11. „ÉÜ„Çπ„ÉàÊà¶Áï•

### 11.1 Âçò‰Ωì„ÉÜ„Çπ„Éà

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::repositories::memory::InMemoryRepository;
    
    #[test]
    fn test_memory_creation() {
        let memory = Memory::new(
            MemoryType::Tech,
            "Test Topic".to_string(),
            "Test Content".to_string(),
        );
        assert!(!memory.id.is_empty());
        assert_eq!(memory.reference_count, 0);
        assert_eq!(memory.confidence, 1.0);
    }
    
    #[tokio::test]
    async fn test_service_remember() {
        let repo = InMemoryRepository::new();
        let mut service = MemoryService::new(repo);
        
        let memory = service.remember(
            MemoryType::Tech,
            "Test".to_string(),
            "Content".to_string(),
            vec![],
            vec![],
            None,
        ).await.unwrap();
        
        assert_eq!(memory.topic, "Test");
    }
    
    #[tokio::test]
    async fn test_service_recall() {
        let repo = InMemoryRepository::new();
        let service = MemoryService::new(repo);
        
        let results = service.recall("test", 10, None, vec![])
            .await.unwrap();
        
        assert!(results.is_empty());
    }
}
```

### 11.2 Áµ±Âêà„ÉÜ„Çπ„Éà

- MCP„Éó„É≠„Éà„Ç≥„É´Ê∫ñÊã†„ÉÜ„Çπ„Éà
- „Ç®„É≥„Éâ„ÉÑ„Éº„Ç®„É≥„Éâ„Ç∑„Éä„É™„Ç™
- „Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê„ÅÆÁ¢∫Ë™ç
- „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà

## 12. Â∞ÜÊù•„ÅÆÊã°ÂºµÂèØËÉΩÊÄß

### 12.1 Phase 4‰ª•Èôç„ÅÆÊ©üËÉΩÂÄôË£ú

- **Èñ¢‰øÇÊÄß„Ç∞„É©„Éï**: memoriesÈñì„ÅÆÈñ¢ÈÄ£„ÇíÁÆ°ÁêÜ
- **Ëá™Âãï„Çø„Ç∞ÁîüÊàê**: content„Åã„ÇâËá™ÂãïÁöÑ„Å´„Çø„Ç∞„ÇíÊäΩÂá∫
- **„Ç§„É≥„Éù„Éº„Éà/„Ç®„ÇØ„Çπ„Éù„Éº„Éà**: JSON/CSVÂΩ¢Âºè„Åß„ÅÆÂÖ•Âá∫Âäõ
- **Web UI**: „Éñ„É©„Ç¶„Ç∂„Åã„ÇâË®òÊÜ∂„ÇíÁÆ°ÁêÜ
- **ÂêåÊúüÊ©üËÉΩ**: Ë§áÊï∞„Éá„Éê„Ç§„ÇπÈñì„Åß„ÅÆÂêåÊúüÔºàÊöóÂè∑Âåñ‰ªò„ÅçÔºâ

### 12.2 Êã°Âºµ„Éù„Ç§„É≥„Éà

- MemoryType„ÅÆËøΩÂä†Ôºà‰æã: personal, teamÔºâ
- Ê§úÁ¥¢„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÊîπÂñÑ
- „Çà„ÇäÈ´òÂ∫¶„Å™ÈáçË§áÊ§úÂá∫
- „Éû„É´„ÉÅ„É¶„Éº„Ç∂„ÉºÂØæÂøú

## 13. v2„Åã„Çâv3„Å∏„ÅÆ‰∏ª„Å™Â§âÊõ¥ÁÇπ

### 13.1 „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÊîπÂñÑ

| È†ÖÁõÆ | v2 | v3 | ÊîπÂñÑÁÇπ |
|------|-----|-----|--------|
| **Â±§ÊßãÈÄ†** | 3Â±§ÔºàÊ∑∑Âú®Ôºâ | 4Â±§ÔºàÊòéÁ¢∫Ôºâ | Ë≤¨‰ªª„ÅÆÊòéÁ¢∫„Å™ÂàÜÈõ¢ |
| **‰æùÂ≠òÊÄßÁÆ°ÁêÜ** | Áõ¥Êé•‰æùÂ≠ò | „Éà„É¨„Ç§„Éà„Å´„Çà„ÇãÊäΩË±°Âåñ | „ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£Âêë‰∏ä |
| **„ÉÜ„Çπ„Éà** | Áµ±Âêà„ÉÜ„Çπ„Éà„ÅÆ„Åø | Âçò‰Ωì„ÉÜ„Çπ„Éà + Áµ±Âêà„ÉÜ„Çπ„Éà | È´òÈÄü„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ |
| **„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥** | rusqlite_migration | Refinery | „Çà„ÇäÊüîËªü„Å™ÁÆ°ÁêÜ |

### 13.2 „Ç≥„Éº„ÉâÂìÅË≥™Âêë‰∏ä

- **SOLIDÂéüÂâá„ÅÆÈÅ©Áî®**: Áâπ„Å´DIPÔºà‰æùÂ≠òÊÄßÈÄÜËª¢„ÅÆÂéüÂâáÔºâ
- **„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞**: thiserror„Å´„Çà„ÇãÊßãÈÄ†Âåñ
- **„Éì„É´„ÉÄ„Éº„Éë„Çø„Éº„É≥**: Memory„ÅÆÊüîËªü„Å™ÊßãÁØâ
- **„Éï„Ç°„ÇØ„Éà„É™Èñ¢Êï∞**: „Çµ„Éº„Éì„Çπ„ÅÆ‰æùÂ≠òÊÄßÊ≥®ÂÖ•

### 13.3 ‰øùÂÆàÊÄßÂêë‰∏ä

- **ÊòéÁ¢∫„Å™Â±§ÂàÜÈõ¢**: ÂêÑÂ±§„ÅÆË≤¨‰ªª„ÅåÊòéÁ¢∫
- **„ÉÜ„Çπ„ÉàÂÆπÊòìÊÄß**: InMemoryRepository„Å´„Çà„ÇãÈ´òÈÄü„ÉÜ„Çπ„Éà
- **Êã°ÂºµÂÆπÊòìÊÄß**: Êñ∞„Åó„ÅÑRepository„ÅÆËøΩÂä†„ÅåÂÆπÊòì

## 14. „Åæ„Å®„ÇÅ

Memory MCP v3„ÅØ„ÄÅ**„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**„Å®**SOLIDÂéüÂâá**„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åß„ÄÅv2„ÅÆË®≠Ë®à„ÇíÂ§ßÂπÖ„Å´ÊîπÂñÑ„Åó„Åæ„Åó„Åü„ÄÇ

### ‰∏ª„Å™Âà©ÁÇπ

1. **È´ò„ÅÑ„ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£**: ‰æùÂ≠òÊÄßÊ≥®ÂÖ•„Å´„Çà„ÇäÂçò‰Ωì„ÉÜ„Çπ„Éà„ÅåÂÆπÊòì
2. **ÊòéÁ¢∫„Å™Ë≤¨‰ªªÂàÜÈõ¢**: 4Â±§ÊßãÈÄ†„Å´„Çà„ÇãÂΩπÂâ≤„ÅÆÊòéÁ¢∫Âåñ
3. **Êã°ÂºµÂÆπÊòìÊÄß**: „Éà„É¨„Ç§„Éà„Å´„Çà„ÇãÊäΩË±°Âåñ„ÅßÊñ∞Ê©üËÉΩËøΩÂä†„ÅåÂÆπÊòì
4. **‰øùÂÆàÊÄßÂêë‰∏ä**: „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„Ç≥„Éº„ÉâÊßãÈÄ†„ÅÆÊîπÂñÑ
5. **ÂÆüÁî®ÁöÑ**: ÊÆµÈöéÁöÑÂÆüË£Ö„ÅßÊó©Êúü„Å´‰æ°ÂÄ§„ÇíÊèê‰æõ

### ÊàêÂäü„ÅÆÈçµ

- **„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: Â±§Èñì„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇíÊòéÁ¢∫Âåñ
- **‰æùÂ≠òÊÄßÊ≥®ÂÖ•**: „ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£„Å®ÊüîËªüÊÄß„ÅÆÂêë‰∏ä
- **ÊÆµÈöéÁöÑÂÆüË£Ö**: ÂêÑ„Éï„Çß„Éº„Ç∫„ÅßÂãï„Åè„ÇÇ„ÅÆ„ÇíÊèê‰æõ
- **„Ç∑„É≥„Éó„É´„Åï„ÅÆÁ∂≠ÊåÅ**: ÂøÖË¶Å„Å™Ë§áÈõëÊÄß„ÅÆ„Åø„ÇíÂ∞éÂÖ•

„Åì„ÅÆË®≠Ë®à„Å´„Çà„Çä„ÄÅ‰øùÂÆàÊÄß„ÅåÈ´ò„Åè„ÄÅÊã°ÂºµÂèØËÉΩ„Åß„ÄÅ„ÉÜ„Çπ„Éà„Åó„ÇÑ„Åô„ÅÑ„É°„É¢„É™„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüÁèæ„Åó„Åæ„Åô„ÄÇ